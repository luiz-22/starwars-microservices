# M칩dulo 1

# 쯈u칠 aprenderemos?

- **Comprender la arquitectura de microservicios** y c칩mo se diferencia de la arquitectura monol칤tica.
- **Dise침ar una aplicaci칩n** utilizando la arquitectura de microservicios.

<br>

# Introducci칩n a la arquitectura

**La arquitectura de microservicios** es un enfoque moderno para desarrollar y desplegar aplicaciones de software que se basa en la idea de construir aplicaciones como **un conjunto de servicios peque침os, aut칩nomos y altamente escalables** que se ejecutan de forma independiente y se comunican entre s칤 a trav칠s de interfaces bien definidas.

> Cada microservicio se enfoca en una 칰nica funcionalidad o tarea espec칤fica y se puede desarrollar, desplegar y escalar de manera independiente, lo que permite una mayor flexibilidad y agilidad en el desarrollo de aplicaciones.

A diferencia de la **arquitectura monol칤tica**, donde todas las funcionalidades se encuentran integradas en una 칰nica aplicaci칩n, la arquitectura de microservicios promueve la divisi칩n de la aplicaci칩n en peque침os servicios independientes que pueden ser desarrollados, desplegados y escalados de forma individual. **Cada microservicio se ejecuta en su propio entorno**, con su propia base de datos, configuraci칩n y recursos, lo que permite una mayor modularidad y autonom칤a.

![arquitectura](./assets/M1/arquitectura.jpg)

Una de las principales caracter칤sticas de la arquitectura de microservicios es la **comunicaci칩n a trav칠s de interfaces** bien definidas. Los microservicios se comunican entre s칤 a trav칠s de interfaces, como **API RESTful, mensajes asincr칩nicos o eventos**, lo que permite una mayor desacoplamiento entre los servicios y facilita la integraci칩n y evoluci칩n de la aplicaci칩n en el tiempo.

Adem치s, la arquitectura de microservicios fomenta el uso de tecnolog칤as y herramientas que facilitan la automatizaci칩n, el monitoreo y la gesti칩n de los servicios, como contenedores, orquestadores, herramientas de descubrimiento de servicios, entre otros.

<br>

# Pros y contras

> Toda arquitectura de desarrollo de software tiene fortalezas (Pros), desventajas (Contras) y limitaciones dependiendo del contexto y objetivo del proyecto.

A continuaci칩n vamos a conocer cuales son las ventajas (Pros) de la arquitectura de microservicios:

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios permiten escalar cada servicio de forma independiente, lo que permite adaptar la capacidad de la aplicaci칩n a las necesidades espec칤ficas, optimizando el uso de recursos.
</details>

<details>
  <summary><b>Flexibilidad y agilidad</b></summary>
  
  Los microservicios facilitan la implementaci칩n de cambios y actualizaciones en la aplicaci칩n de manera r치pida y aislada, sin afectar a otros servicios, lo que permite una mayor flexibilidad y agilidad en el desarrollo y despliegue de aplicaciones.
</details>

<details>
  <summary><b>Modularidad</b></summary>
  
  Los microservicios se enfocan en una 칰nica funcionalidad o tarea, lo que permite una mayor modularidad en el dise침o y desarrollo de la aplicaci칩n. Esto facilita la reutilizaci칩n, el mantenimiento y la evoluci칩n de los servicios de forma individual.
</details>

<details>
  <summary><b>Independencia tecnol칩gica</b></summary>
  
  Cada microservicio puede utilizar diferentes tecnolog칤as, bases de datos y frameworks, lo que permite una mayor libertad en la elecci칩n de tecnolog칤as y herramientas adecuadas para cada servicio, sin estar limitado por una 칰nica tecnolog칤a en toda la aplicaci칩n.
</details>

<details>
  <summary><b>Desacoplamiento</b></summary>
  
  Los microservicios se comunican a trav칠s de interfaces bien definidas, lo que permite un bajo acoplamiento entre los servicios. Esto facilita la integraci칩n con otros sistemas y permite una mayor evoluci칩n y compatibilidad de la aplicaci칩n en el tiempo.
</details>  
  
<br>

Luego de conoces sus fortalezas, tambi칠n es fundamental conocer las **limitaciones o desventajas** de este tipo de arquitectura.

<details>
  <summary><b>Complejidad</b></summary>
  
  La gesti칩n de un sistema distribuido de microservicios puede ser compleja, ya que implica la orquestaci칩n, monitorizaci칩n y gesti칩n de m칰ltiples servicios en diferentes entornos.
</details>

<details>
  <summary><b>Mayor overhead</b></summary>
  
  La comunicaci칩n entre microservicios puede tener un overhead adicional, como la latencia de red y la necesidad de implementar mecanismos de seguridad y gesti칩n de errores en las interfaces de comunicaci칩n.
</details>

<details>
  <summary><b>Mayor esfuerzo de desarrollo inicial</b></summary>
  
  La construcci칩n de una arquitectura de microservicios puede requerir un mayor esfuerzo de desarrollo inicial para la creaci칩n y configuraci칩n de m칰ltiples servicios, infraestructuras de comunicaci칩n y herramientas de gesti칩n.
</details>

<details>
  <summary><b>Mayor complejidad en el despliegue</b></summary>
  
  El despliegue de microservicios puede requerir una mayor complejidad en la gesti칩n de la infraestructura, como el uso de herramientas de orquestaci칩n de contenedores y sistemas de descubrimiento de servicios.
</details>

<details>
  <summary><b>Reto en la gesti칩n de transacciones</b></summary>
  
  La gesti칩n de transacciones en una arquitectura de microservicios puede ser m치s compleja, ya que las transacciones distribuidas pueden ser dif칤ciles de manejar entre diferentes servicios.
</details>

<br>

# Introducci칩n a Docker

> "Es una plataforma de virtualizaci칩n a nivel de sistema operativo que permite la creaci칩n, empaquetado y distribuci칩n de aplicaciones en contenedores. Los contenedores Docker son aislados y encapsulan todo lo necesario para que una aplicaci칩n se ejecute de manera consistente en cualquier entorno, independientemente de las diferencias en la infraestructura subyacente"  
> RedHat.com

### **En otras palabras, podemos decir que...**

Docker es una herramienta que te permite **empaquetar tu aplicaci칩n Node.js, junto con todas sus dependencias y configuraciones**, en un 'contenedor' port치til. Este contenedor se asemeja a un caja virtual que contiene todo lo necesario para que tu aplicaci칩n Node.js funcione correctamente, incluyendo la versi칩n espec칤fica de Node.js, las bibliotecas y todos los paquetes de npm necesarios.

Imagina que tu aplicaci칩n Node.js es una casa con sus propios muebles y electrodom칠sticos. Docker ser칤a como una caja de mudanza que empaca todos los elementos necesarios para tu casa en un solo lugar, de manera ordenada y segura. Luego, puedes llevar esa caja de mudanza a cualquier lugar, como un nuevo servidor o el entorno de desarrollo de tu colega, y asegurarte de que todos los elementos de tu casa est칠n en su lugar correcto y funcionando sin problemas.

[En el siguiente video 游 podr치s conocer la importancia de Docker y su potencial](https://www.youtube.com/watch?v=-bS36SMr2Yw)

Adem치s de los beneficios comentados en el video anterior, **Docker** es una herramienta extremadamente 칰til al **trabajar con microservicios** por varias razones que detallamos a continuaci칩n:

<details>
  <summary><b>Independencia de dependencias</b></summary>
  
  Los microservicios suelen ser peque침as aplicaciones o componentes de una aplicaci칩n m치s grande que se ejecutan de forma independiente. Cada microservicio puede tener sus propias dependencias y configuraciones espec칤ficas. Docker permite empaquetar cada microservicio junto con sus dependencias en un contenedor independiente. Esto asegura que cada microservicio tenga su propio entorno aislado y no se vea afectado por las dependencias de otros microservicios o del sistema operativo en el que se ejecutan.
</details>

<details>
  <summary><b>Portabilidad</b></summary>
  
  Docker permite empaquetar un microservicio y todas sus dependencias en un contenedor, lo que lo hace altamente port치til. Puedes mover f치cilmente el contenedor de un entorno a otro, como de desarrollo a producci칩n, o entre diferentes servidores o plataformas en la nube. Esto facilita la implementaci칩n y despliegue de microservicios en diferentes entornos sin preocuparse por las diferencias en la configuraci칩n del sistema operativo o las dependencias.
</details>

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios suelen dise침arse para escalar horizontalmente, lo que significa que se pueden ejecutar varias instancias del mismo microservicio para manejar cargas de trabajo crecientes. Docker facilita la replicaci칩n y el escalado de microservicios al permitir la creaci칩n de m칰ltiples contenedores a partir de la misma imagen de Docker. Esto hace que sea sencillo agregar o quitar instancias de microservicios seg칰n sea necesario para adaptarse a los cambios en la demanda.
</details>

<details>
  <summary><b>Consistencia y reproducibilidad</b></summary>
  
  Docker asegura que los microservicios se ejecuten de la misma manera en todos los entornos, lo que garantiza la consistencia en el desarrollo, prueba y producci칩n. Adem치s, Docker permite definir la configuraci칩n del contenedor en un archivo llamado Dockerfile, lo que facilita la reproducci칩n del entorno de ejecuci칩n del microservicio en diferentes etapas del ciclo de vida del desarrollo de software, desde el desarrollo local hasta la producci칩n.
</details>

<details>
  <summary><b>Facilidad en la gesti칩n</b></summary>
  
  Docker proporciona una interfaz de l칤nea de comandos y una interfaz gr치fica de usuario que facilita la gesti칩n de los contenedores de microservicios. Puedes iniciar, detener, reiniciar o eliminar contenedores con simples comandos o acciones de interfaz gr치fica. Adem치s, Docker tiene una amplia comunidad y un ecosistema de herramientas y servicios que facilitan la gesti칩n y monitoreo de microservicios.
</details>

<br>

# Instalaci칩n de Docker

Luego de conocer los beneficios de Docker, vamos a **instalar la aplicaci칩n** en tu sistema operativo.

[En el siguiente video podr치s conocer como instalar Docker en Windows](https://www.youtube.com/watch?v=BK-C2RofmTE&t=16s)

Luego de instalar Docker correctamente, vamos explorar c칩mo crear un Aplicaci칩n de NodeJS en Docker.

[Enlace](https://www.youtube.com/watch?v=iLlmm0L-VpQ&t=47s)

En el video anterior se demostr칩 como crear una aplicaci칩n sencilla en Docker, ahora vamos a poner manos a la obra para comenzar con nuestra primera **Homework**.

<br>

# Proyecto Star Wars API

Para esta actividad deber치s contar con este [repositorio](https://github.com/soyHenry/be-ct-upskilling-microservicios) (o la carpeta repositorio), ser치 la base de lo que estaremos creando. Este proyecto se trata de una **API de Star Wars**, que maneja informaci칩n sobre los personajes de la franquicia (Characters), las pel칤culas que se han lanzado (Films) y los planetas que aparecen en dichas pel칤culas (Planets).

Podr치s notar que este repositorio contiene un proyecto de **Nodejs** similar a los que ya has desarrollado durante la carrera:

1. Un servidor web HTTP creado con la librer칤a Express.
2. Un enrutador al cual el servidor le delega el enrutado de la aplicaci칩n.
3. Tres (3) routers que se encargan de definir rutas para cada una de las entidades que trabajamos (Films, Characters y Planets).
4. Los controladores de las rutas no se comunican (por el momento) con ninguna Base de Datos, sino que obtienen los datos a partir de unos archivos Json que contienen los registros para cada una de las entidades.

![repositorio](./assets/M1/repositorio.jpg)

![starwars api](./assets/M1/star_wars_api.png)

Te dejamos adem치s un vistazo del **package.json** que posee hasta el momento con las dependencias instaladas. Por el momento **no necesitaremos m치s dependencias que estas**.

![package.json](./assets/M1/package_json.png)

Tanto la estructura del proyecto como las funcionalidades que posee hasta el momento son las que ya conocemos. Esta aplicaci칩n, como ver치s, se ajusta a la **estructura monol칤tica** que vimos en pasos anteriores:

- Cuenta con una 칰nica aplicaci칩n de Express que se encarga de manejar todo el servicio.
- Toda la aplicaci칩n se expone en un 칰nico puerto del host donde se encuentre.
- Si bien la l칩gica de negocio de la aplicaci칩n se ir치 definiendo en rutas y enrutadores distintos, al final del camino todo forma parte de una 칰nica aplicaci칩n.

## -------------------- **Clase** --------------------

El objetivo es poder hacer que toda la l칩gica este dividida en microservicios. Cuando hablamos de microservicios, estamos hablando de peque침as aplicaciones de Express en nuestro caso.

Nuestro objetivo es poder hacer que tengamos tres aplicaciones peque침as, una que se encargue de gestionar la informaci칩n de los personajes, otra que se encargue de gestionar la informaci칩n de las pel칤culas y otra de los planetas.

Los controladores de las rutas, manejan los datos de un json, m치s adelante lo pasaremos a una base de datos. Vamos a ver que la gesti칩n de los datos en la base de datos, tambi칠n sea un microservicio aparte.

## -------------------- **Fin clase** --------------------

<br>

# HW 1 - Actividad 1

Esta primera Homework est치 estructurada en dos actividades con objetivos muy espec칤ficos:

## Actividad 1

Debes lograr **dividir esta aplicaci칩n en aplicaciones m치s peque침as y sencillas**, que involucren un 칰nico aspecto, entidad o funcionalidad del proyecto.

El objetivo es dividir nuestro proyecto en una estructura similar a la siguiente:

![starwars api](./assets/M1/star_wars_api2.png)

Como podr치s ver 游, contaremos con una **API Gateway** que se encargar치 de redirigir las peticiones al servicio que corresponda seg칰n la petici칩n. Este gateway no es m치s que una aplicaci칩n de Express que escuchar치 las peticiones en un puerto de tu host.

A su vez, **cada uno de estos servicios ser치 una aplicaci칩n de Express individual**, que estar치 escuchando peticiones en un puerto distinto y que contar치 tambi칠n con sus capas (capa de enrutado, capa de controladores, capa de datos "por el momento los .json").

Respecto a c칩mo la API Gateway redirigir치 las peticiones, lo har치 realizando nuevas peticiones HTTP a los host:port donde est칠n escuchando cada uno de los dem치s servicios.

De esta manera, el cliente realizar치 sus peticiones **칔NICAMENTE al API Gateway**, y ser치 este quien se encargue de comunicarse con los microservicios involucrados en cada petici칩n.

> Para llevar adelante esta actividad te recomendamos que **inicies una nueva carpeta** dentro de la cual podr치s trabajar cada uno de los proyectos de Node por separado. Puedes incluir cualquier dependencia que quieras o creas necesaria aparte de las propuestas en el package.json original.

<br>

## 춰Debemos ir por partes! (PASO 1)

Como primer paso es recomendable **separar para cada una de las entidades que estamos manejando una aplicaci칩n de Express diferente**. Cada una de ellas contar치 con la estructura b치sica ya conocida de las aplicaciones de esta naturaleza.

Para este paso es recomendable trabajar cada una de las aplicaciones como algo totalmente independiente del resto de la estructura. Como si estuvieras haciendo una Rest API s칰per sencilla que maneja datos de una 칰nica entidad.

Al final de este paso deber칤as tener algo similar a lo siguiente:

![estructura carpetas](./assets/M1/estructura_carpetas.jpg)

![escuchando puertos](./assets/M1/escuchando_puertos.jpg)

## -------------------- **Clase** --------------------

Vamos a crear el servicio de `characters`. Lo mismo hay que hacer con los otros servicios.

Iniciamos el proyecto:

```bash
npm init -y
```

Voy creando la carpeta `src` y el archivo `index.js`. Tambi칠n voy instalando algunas dependencias:

```bash
npm i express morgan
```

Creamos el archivo `server.js` dentro de la carpeta `src` donde creamos nuestro servidor de Express:  
`server.js`

```js
const express = require("express");

const server = express();

module.exports = server;
```

Completamos el archivo `index.js` y lo pongamos a escuchar en el puerto `8001` y los otros servicios lo puedo poner a escuchar en el puerto `8002` y `8003` respectivamente:  
`index.js`

```js
const server = require("./src/server");

const PORT = 8001;

server.listen(PORT, () => {
  console.log(`Characters service listening on port ${PORT}`);
});
```

Agregamos `nodemon`:

```bash
npm i nodemon -D
```

Modificamos el archivo `package.json`:  
`package.json`

```json
{
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  }
}
```

Ahora lo podemos correr:

```bash
npm run dev
```

Creo una carpeta `data` y `routes` dentro de `src` para ir estructurando.

Vamos a seguir configurando `server.js`:

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

module.exports = server;
```

Creamos un archivo `index.js` en la carpeta `routes` y lo vamos completando, para que el `server.js` pueda requerirlo y a partir de all칤 empezar a delegar este servicio:  
`routes/index.js`

```js
const { Router } = require("express");

const router = Router();

module.exports = router;
```

`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

module.exports = server;
```

Ahora vamos a ver la estructura o las capas que le vamos a dar cuando vayan pasando nuestra `requests`.

Si el `gateway` ha hecho llegar la `request` al microservicio de `characters`, es por que ya es de `characters`.

Voy a crear un controlador, que es la funci칩n que administra la l칩gica, donde esta volcada toda la l칩gica de negocio para alg칰n endpoint en particular.

Por eso lo m치s recomendable, es trabajar con una carpeta de `controllers`, la creamos, para que podamos tener todas las funciones definidas en otros m칩dulos.

Es bastante recomendable crear en la carpeta `controllers`, un archivo `index.js`, que va a ser el 칤ndice de todos los controladores que haya en esta carpeta:  
`controllers/index.js`

```js
module.exports = {
  getCharacters: require("./getCharacters"),
  createCharacter: require("./createCharacter"),
};
```

Creamos `getCharacters.js` y `createCharacter.js`:  
`controllers/getCharacters.js`

```js
module.exports = (req, res) => {
  res.status(200).send("personajes");
};
```

`controllers/createCharacter.js.js`

```js
module.exports = (req, res) => {
  res.status(200).send("creando personaje");
};
```

Agregamos en el `index.js` de la carpeta `routes`, indicandoles las `callback` que se ejecuta en cada endponint:  
`routes/index.js`

```js
const { Router } = require("express");
const controllers = require("../controllers");

const router = Router();

router.get("/", controllers.getCharacters);

router.post("/", controllers.createCharacter);

module.exports = router;
```

Esta forma de trabajar, tiene una gran ventaja en el manejo de errores. Si trabajamos de forma correcta y bien modularizada, podemos tener un manejo de errores teniendo un c칩digo que se encargue de esto y sea eficiente.

Dentro de la carpeta `data`, deber칤amos tener el `character.json`, sino lo traemos de la carpeta original de cuando empezamos la actividad.

Vamos a empezar a usar este archivo `json`, ya que no tenemos una base de datos real.

Vamos a empezar a crear la capa de datos de este microservicio.

Vamos a crear un archivo `index.js` dentro de la carpeta `data` para traer el `json`. Vamos a definir unas funciones que simulara ser el modelo. La funci칩n `list` retorna los personajes que hay en el `json`. Ahora lo saca de `json`, pero m치s adelante lo puede sacar de una base de datos, de un array, etc:

Ahora lo usamos en `getCharacters`, que lo utiliza como si fuera un modelo m치s, que podr칤a ser de una base de datos, pero es un modelo de mentira, pero que est치 funcionando. Lo que logro es que ya pueda dejar planteado del lado del controlador cual es el c칩digo con el que despu칠s voy a usar en la base de datos. `Character` luego ser치 un modelo de una base de datos no relacional, pero cuando eso cambie, el controlador no va a cambiar absolutamente en nada.
Y para asegurarnos que no cambie, le voy a decir que funci칩n `list` sea as칤ncrona, para que ya definitivamente simular ese comportamiento:  
`routes/index.js`

```js
const planets = require("./planets.json");

module.exports = {
  list: async () => {
    return planets;
  },
};
```

Completamos `getCharacters.js`:  
`getCharacters.js`

```js
const Characters = require("../data")

module.exports = async (req, res) => {
    const characters = await Characters.list()
    res.status(200).json(characters);
}
```

M치s adelante vamos a ver una mejor forma de manejar errores que un `try...catch`.

Toda esta actividad la podemos replicar con `films` y `planets`. 

## -------------------- **Fin clase** --------------------
