# M√≥dulo 1

# ¬øQu√© aprenderemos?

- **Comprender la arquitectura de microservicios** y c√≥mo se diferencia de la arquitectura monol√≠tica.
- **Dise√±ar una aplicaci√≥n** utilizando la arquitectura de microservicios.

<br>

# Introducci√≥n a la arquitectura

**La arquitectura de microservicios** es un enfoque moderno para desarrollar y desplegar aplicaciones de software que se basa en la idea de construir aplicaciones como **un conjunto de servicios peque√±os, aut√≥nomos y altamente escalables** que se ejecutan de forma independiente y se comunican entre s√≠ a trav√©s de interfaces bien definidas.

> Cada microservicio se enfoca en una √∫nica funcionalidad o tarea espec√≠fica y se puede desarrollar, desplegar y escalar de manera independiente, lo que permite una mayor flexibilidad y agilidad en el desarrollo de aplicaciones.

A diferencia de la **arquitectura monol√≠tica**, donde todas las funcionalidades se encuentran integradas en una √∫nica aplicaci√≥n, la arquitectura de microservicios promueve la divisi√≥n de la aplicaci√≥n en peque√±os servicios independientes que pueden ser desarrollados, desplegados y escalados de forma individual. **Cada microservicio se ejecuta en su propio entorno**, con su propia base de datos, configuraci√≥n y recursos, lo que permite una mayor modularidad y autonom√≠a.

![arquitectura](./assets/M1/arquitectura.jpg)

Una de las principales caracter√≠sticas de la arquitectura de microservicios es la **comunicaci√≥n a trav√©s de interfaces** bien definidas. Los microservicios se comunican entre s√≠ a trav√©s de interfaces, como **API RESTful, mensajes asincr√≥nicos o eventos**, lo que permite una mayor desacoplamiento entre los servicios y facilita la integraci√≥n y evoluci√≥n de la aplicaci√≥n en el tiempo.

Adem√°s, la arquitectura de microservicios fomenta el uso de tecnolog√≠as y herramientas que facilitan la automatizaci√≥n, el monitoreo y la gesti√≥n de los servicios, como contenedores, orquestadores, herramientas de descubrimiento de servicios, entre otros.

<br>

# Pros y contras

> Toda arquitectura de desarrollo de software tiene fortalezas (Pros), desventajas (Contras) y limitaciones dependiendo del contexto y objetivo del proyecto.

A continuaci√≥n vamos a conocer cuales son las ventajas (Pros) de la arquitectura de microservicios:

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios permiten escalar cada servicio de forma independiente, lo que permite adaptar la capacidad de la aplicaci√≥n a las necesidades espec√≠ficas, optimizando el uso de recursos.
</details>

<details>
  <summary><b>Flexibilidad y agilidad</b></summary>
  
  Los microservicios facilitan la implementaci√≥n de cambios y actualizaciones en la aplicaci√≥n de manera r√°pida y aislada, sin afectar a otros servicios, lo que permite una mayor flexibilidad y agilidad en el desarrollo y despliegue de aplicaciones.
</details>

<details>
  <summary><b>Modularidad</b></summary>
  
  Los microservicios se enfocan en una √∫nica funcionalidad o tarea, lo que permite una mayor modularidad en el dise√±o y desarrollo de la aplicaci√≥n. Esto facilita la reutilizaci√≥n, el mantenimiento y la evoluci√≥n de los servicios de forma individual.
</details>

<details>
  <summary><b>Independencia tecnol√≥gica</b></summary>
  
  Cada microservicio puede utilizar diferentes tecnolog√≠as, bases de datos y frameworks, lo que permite una mayor libertad en la elecci√≥n de tecnolog√≠as y herramientas adecuadas para cada servicio, sin estar limitado por una √∫nica tecnolog√≠a en toda la aplicaci√≥n.
</details>

<details>
  <summary><b>Desacoplamiento</b></summary>
  
  Los microservicios se comunican a trav√©s de interfaces bien definidas, lo que permite un bajo acoplamiento entre los servicios. Esto facilita la integraci√≥n con otros sistemas y permite una mayor evoluci√≥n y compatibilidad de la aplicaci√≥n en el tiempo.
</details>  
  
<br>

Luego de conoces sus fortalezas, tambi√©n es fundamental conocer las **limitaciones o desventajas** de este tipo de arquitectura.

<details>
  <summary><b>Complejidad</b></summary>
  
  La gesti√≥n de un sistema distribuido de microservicios puede ser compleja, ya que implica la orquestaci√≥n, monitorizaci√≥n y gesti√≥n de m√∫ltiples servicios en diferentes entornos.
</details>

<details>
  <summary><b>Mayor overhead</b></summary>
  
  La comunicaci√≥n entre microservicios puede tener un overhead adicional, como la latencia de red y la necesidad de implementar mecanismos de seguridad y gesti√≥n de errores en las interfaces de comunicaci√≥n.
</details>

<details>
  <summary><b>Mayor esfuerzo de desarrollo inicial</b></summary>
  
  La construcci√≥n de una arquitectura de microservicios puede requerir un mayor esfuerzo de desarrollo inicial para la creaci√≥n y configuraci√≥n de m√∫ltiples servicios, infraestructuras de comunicaci√≥n y herramientas de gesti√≥n.
</details>

<details>
  <summary><b>Mayor complejidad en el despliegue</b></summary>
  
  El despliegue de microservicios puede requerir una mayor complejidad en la gesti√≥n de la infraestructura, como el uso de herramientas de orquestaci√≥n de contenedores y sistemas de descubrimiento de servicios.
</details>

<details>
  <summary><b>Reto en la gesti√≥n de transacciones</b></summary>
  
  La gesti√≥n de transacciones en una arquitectura de microservicios puede ser m√°s compleja, ya que las transacciones distribuidas pueden ser dif√≠ciles de manejar entre diferentes servicios.
</details>

<br>

# Introducci√≥n a Docker

> "Es una plataforma de virtualizaci√≥n a nivel de sistema operativo que permite la creaci√≥n, empaquetado y distribuci√≥n de aplicaciones en contenedores. Los contenedores Docker son aislados y encapsulan todo lo necesario para que una aplicaci√≥n se ejecute de manera consistente en cualquier entorno, independientemente de las diferencias en la infraestructura subyacente"  
> RedHat.com

### **En otras palabras, podemos decir que...**

Docker es una herramienta que te permite **empaquetar tu aplicaci√≥n Node.js, junto con todas sus dependencias y configuraciones**, en un 'contenedor' port√°til. Este contenedor se asemeja a un caja virtual que contiene todo lo necesario para que tu aplicaci√≥n Node.js funcione correctamente, incluyendo la versi√≥n espec√≠fica de Node.js, las bibliotecas y todos los paquetes de npm necesarios.

Imagina que tu aplicaci√≥n Node.js es una casa con sus propios muebles y electrodom√©sticos. Docker ser√≠a como una caja de mudanza que empaca todos los elementos necesarios para tu casa en un solo lugar, de manera ordenada y segura. Luego, puedes llevar esa caja de mudanza a cualquier lugar, como un nuevo servidor o el entorno de desarrollo de tu colega, y asegurarte de que todos los elementos de tu casa est√©n en su lugar correcto y funcionando sin problemas.

[En el siguiente video üëÄ podr√°s conocer la importancia de Docker y su potencial](https://www.youtube.com/watch?v=-bS36SMr2Yw)

Adem√°s de los beneficios comentados en el video anterior, **Docker** es una herramienta extremadamente √∫til al **trabajar con microservicios** por varias razones que detallamos a continuaci√≥n:

<details>
  <summary><b>Independencia de dependencias</b></summary>
  
  Los microservicios suelen ser peque√±as aplicaciones o componentes de una aplicaci√≥n m√°s grande que se ejecutan de forma independiente. Cada microservicio puede tener sus propias dependencias y configuraciones espec√≠ficas. Docker permite empaquetar cada microservicio junto con sus dependencias en un contenedor independiente. Esto asegura que cada microservicio tenga su propio entorno aislado y no se vea afectado por las dependencias de otros microservicios o del sistema operativo en el que se ejecutan.
</details>

<details>
  <summary><b>Portabilidad</b></summary>
  
  Docker permite empaquetar un microservicio y todas sus dependencias en un contenedor, lo que lo hace altamente port√°til. Puedes mover f√°cilmente el contenedor de un entorno a otro, como de desarrollo a producci√≥n, o entre diferentes servidores o plataformas en la nube. Esto facilita la implementaci√≥n y despliegue de microservicios en diferentes entornos sin preocuparse por las diferencias en la configuraci√≥n del sistema operativo o las dependencias.
</details>

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios suelen dise√±arse para escalar horizontalmente, lo que significa que se pueden ejecutar varias instancias del mismo microservicio para manejar cargas de trabajo crecientes. Docker facilita la replicaci√≥n y el escalado de microservicios al permitir la creaci√≥n de m√∫ltiples contenedores a partir de la misma imagen de Docker. Esto hace que sea sencillo agregar o quitar instancias de microservicios seg√∫n sea necesario para adaptarse a los cambios en la demanda.
</details>

<details>
  <summary><b>Consistencia y reproducibilidad</b></summary>
  
  Docker asegura que los microservicios se ejecuten de la misma manera en todos los entornos, lo que garantiza la consistencia en el desarrollo, prueba y producci√≥n. Adem√°s, Docker permite definir la configuraci√≥n del contenedor en un archivo llamado Dockerfile, lo que facilita la reproducci√≥n del entorno de ejecuci√≥n del microservicio en diferentes etapas del ciclo de vida del desarrollo de software, desde el desarrollo local hasta la producci√≥n.
</details>

<details>
  <summary><b>Facilidad en la gesti√≥n</b></summary>
  
  Docker proporciona una interfaz de l√≠nea de comandos y una interfaz gr√°fica de usuario que facilita la gesti√≥n de los contenedores de microservicios. Puedes iniciar, detener, reiniciar o eliminar contenedores con simples comandos o acciones de interfaz gr√°fica. Adem√°s, Docker tiene una amplia comunidad y un ecosistema de herramientas y servicios que facilitan la gesti√≥n y monitoreo de microservicios.
</details>

<br>

# Instalaci√≥n de Docker

Luego de conocer los beneficios de Docker, vamos a **instalar la aplicaci√≥n** en tu sistema operativo.

[En el siguiente video podr√°s conocer como instalar Docker en Windows](https://www.youtube.com/watch?v=BK-C2RofmTE&t=16s)

Luego de instalar Docker correctamente, vamos explorar c√≥mo crear un Aplicaci√≥n de NodeJS en Docker.

[Enlace](https://www.youtube.com/watch?v=iLlmm0L-VpQ&t=47s)

En el video anterior se demostr√≥ como crear una aplicaci√≥n sencilla en Docker, ahora vamos a poner manos a la obra para comenzar con nuestra primera **Homework**.

<br>

# Proyecto Star Wars API

Para esta actividad deber√°s contar con este [repositorio](https://github.com/soyHenry/be-ct-upskilling-microservicios) (o la carpeta repositorio), ser√° la base de lo que estaremos creando. Este proyecto se trata de una **API de Star Wars**, que maneja informaci√≥n sobre los personajes de la franquicia (Characters), las pel√≠culas que se han lanzado (Films) y los planetas que aparecen en dichas pel√≠culas (Planets).

Podr√°s notar que este repositorio contiene un proyecto de **Nodejs** similar a los que ya has desarrollado durante la carrera:

1. Un servidor web HTTP creado con la librer√≠a Express.
2. Un enrutador al cual el servidor le delega el enrutado de la aplicaci√≥n.
3. Tres (3) routers que se encargan de definir rutas para cada una de las entidades que trabajamos (Films, Characters y Planets).
4. Los controladores de las rutas no se comunican (por el momento) con ninguna Base de Datos, sino que obtienen los datos a partir de unos archivos Json que contienen los registros para cada una de las entidades.

![repositorio](./assets/M1/repositorio.jpg)

![starwars api](./assets/M1/star_wars_api.png)

Te dejamos adem√°s un vistazo del **package.json** que posee hasta el momento con las dependencias instaladas. Por el momento **no necesitaremos m√°s dependencias que estas**.

![package.json](./assets/M1/package_json.png)

Tanto la estructura del proyecto como las funcionalidades que posee hasta el momento son las que ya conocemos. Esta aplicaci√≥n, como ver√°s, se ajusta a la **estructura monol√≠tica** que vimos en pasos anteriores:

- Cuenta con una √∫nica aplicaci√≥n de Express que se encarga de manejar todo el servicio.
- Toda la aplicaci√≥n se expone en un √∫nico puerto del host donde se encuentre.
- Si bien la l√≥gica de negocio de la aplicaci√≥n se ir√° definiendo en rutas y enrutadores distintos, al final del camino todo forma parte de una √∫nica aplicaci√≥n.

## -------------------- **Clase** --------------------

El objetivo es poder hacer que toda la l√≥gica este dividida en microservicios. Cuando hablamos de microservicios, estamos hablando de peque√±as aplicaciones de Express en nuestro caso.

Nuestro objetivo es poder hacer que tengamos tres aplicaciones peque√±as, una que se encargue de gestionar la informaci√≥n de los personajes, otra que se encargue de gestionar la informaci√≥n de las pel√≠culas y otra de los planetas.

Los controladores de las rutas, manejan los datos de un json, m√°s adelante lo pasaremos a una base de datos. Vamos a ver que la gesti√≥n de los datos en la base de datos, tambi√©n sea un microservicio aparte.

## -------------------- **Fin clase** --------------------

<br>

# HW 1 - Actividad 1

Esta primera Homework est√° estructurada en dos actividades con objetivos muy espec√≠ficos:

## Actividad 1

Debes lograr **dividir esta aplicaci√≥n en aplicaciones m√°s peque√±as y sencillas**, que involucren un √∫nico aspecto, entidad o funcionalidad del proyecto.

El objetivo es dividir nuestro proyecto en una estructura similar a la siguiente:

![starwars api](./assets/M1/star_wars_api2.png)

Como podr√°s ver üëÄ, contaremos con una **API Gateway** que se encargar√° de redirigir las peticiones al servicio que corresponda seg√∫n la petici√≥n. Este gateway no es m√°s que una aplicaci√≥n de Express que escuchar√° las peticiones en un puerto de tu host.

A su vez, **cada uno de estos servicios ser√° una aplicaci√≥n de Express individual**, que estar√° escuchando peticiones en un puerto distinto y que contar√° tambi√©n con sus capas (capa de enrutado, capa de controladores, capa de datos "por el momento los .json").

Respecto a c√≥mo la API Gateway redirigir√° las peticiones, lo har√° realizando nuevas peticiones HTTP a los host:port donde est√©n escuchando cada uno de los dem√°s servicios.

De esta manera, el cliente realizar√° sus peticiones **√öNICAMENTE al API Gateway**, y ser√° este quien se encargue de comunicarse con los microservicios involucrados en cada petici√≥n.

> Para llevar adelante esta actividad te recomendamos que **inicies una nueva carpeta** dentro de la cual podr√°s trabajar cada uno de los proyectos de Node por separado. Puedes incluir cualquier dependencia que quieras o creas necesaria aparte de las propuestas en el package.json original.

<br>

## ¬°Debemos ir por partes! (PASO 1)

Como primer paso es recomendable **separar para cada una de las entidades que estamos manejando una aplicaci√≥n de Express diferente**. Cada una de ellas contar√° con la estructura b√°sica ya conocida de las aplicaciones de esta naturaleza.

Para este paso es recomendable trabajar cada una de las aplicaciones como algo totalmente independiente del resto de la estructura. Como si estuvieras haciendo una Rest API s√∫per sencilla que maneja datos de una √∫nica entidad.

Al final de este paso deber√≠as tener algo similar a lo siguiente:

![estructura carpetas](./assets/M1/estructura_carpetas.jpg)

![escuchando puertos](./assets/M1/escuchando_puertos.jpg)

## -------------------- **Clase** --------------------

Iniciamos el proyecto.

Vamos a crear el servicio de `characters`. Lo mismo hay que hacer con los otros servicios.

Iniciamos el proyecto:

```bash
npm init -y
```

Voy creando la carpeta `src` y el archivo `index.js`. Tambi√©n voy instalando algunas dependencias:

```bash
npm i express morgan
```

Creamos el archivo `server.js` dentro de la carpeta `src` donde creamos nuestro servidor de Express:  
`server.js`

```js
const express = require("express");

const server = express();

module.exports = server;
```

Completamos el archivo `index.js` y lo pongamos a escuchar en el puerto `8001` y los otros servicios lo puedo poner a escuchar en el puerto `8002` y `8003` respectivamente:  
`index.js`

```js
const server = require("./src/server");

const PORT = 8001;

server.listen(PORT, () => {
  console.log(`Characters service listening on port ${PORT}`);
});
```

Agregamos `nodemon`:

```bash
npm i nodemon -D
```

Modificamos el archivo `package.json`:  
`package.json`

```json
{
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  }
}
```

Ahora lo podemos correr:

```bash
npm run dev
```

Creo una carpeta `data` y `routes` dentro de `src` para ir estructurando.

Vamos a seguir configurando `server.js`:

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

module.exports = server;
```

Creamos un archivo `index.js` en la carpeta `routes` y lo vamos completando, para que el `server.js` pueda requerirlo y a partir de all√≠ empezar a delegar este servicio:  
`routes/index.js`

```js
const { Router } = require("express");

const router = Router();

module.exports = router;
```

`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

module.exports = server;
```

Ahora vamos a ver la estructura o las capas que le vamos a dar cuando vayan pasando nuestra `requests`.

Si el `gateway` ha hecho llegar la `request` al microservicio de `characters`, es por que ya es de `characters`.

Voy a crear un controlador, que es la funci√≥n que administra la l√≥gica, donde esta volcada toda la l√≥gica de negocio para alg√∫n endpoint en particular.

Por eso lo m√°s recomendable, es trabajar con una carpeta de `controllers`, la creamos, para que podamos tener todas las funciones definidas en otros m√≥dulos.

Es bastante recomendable crear en la carpeta `controllers`, un archivo `index.js`, que va a ser el √≠ndice de todos los controladores que haya en esta carpeta:  
`controllers/index.js`

```js
module.exports = {
  getCharacters: require("./getCharacters"),
  createCharacter: require("./createCharacter"),
};
```

Creamos `getCharacters.js` y `createCharacter.js`:  
`controllers/getCharacters.js`

```js
module.exports = (req, res) => {
  res.status(200).send("personajes");
};
```

`controllers/createCharacter.js.js`

```js
module.exports = (req, res) => {
  res.status(200).send("creando personaje");
};
```

Agregamos en el `index.js` de la carpeta `routes`, indicandoles las `callback` que se ejecuta en cada endponint:  
`routes/index.js`

```js
const { Router } = require("express");
const controllers = require("../controllers");

const router = Router();

router.get("/", controllers.getCharacters);

router.post("/", controllers.createCharacter);

module.exports = router;
```

Esta forma de trabajar, tiene una gran ventaja en el manejo de errores. Si trabajamos de forma correcta y bien modularizada, podemos tener un manejo de errores teniendo un c√≥digo que se encargue de esto y sea eficiente.

Dentro de la carpeta `data`, deber√≠amos tener el `character.json`, sino lo traemos de la carpeta original de cuando empezamos la actividad.

Vamos a empezar a usar este archivo `json`, ya que no tenemos una base de datos real.

Vamos a empezar a crear la capa de datos de este microservicio.

Vamos a crear un archivo `index.js` dentro de la carpeta `data` para traer el `json`. Vamos a definir unas funciones que simulara ser el modelo. La funci√≥n `list` retorna los personajes que hay en el `json`. Ahora lo saca de `json`, pero m√°s adelante lo puede sacar de una base de datos, de un array, etc:

Ahora lo usamos en `getCharacters`, que lo utiliza como si fuera un modelo m√°s, que podr√≠a ser de una base de datos, pero es un modelo de mentira, pero que est√° funcionando. Lo que logro es que ya pueda dejar planteado del lado del controlador cual es el c√≥digo con el que despu√©s voy a usar en la base de datos. `Character` luego ser√° un modelo de una base de datos no relacional, pero cuando eso cambie, el controlador no va a cambiar absolutamente en nada.
Y para asegurarnos que no cambie, le voy a decir que funci√≥n `list` sea as√≠ncrona, para que ya definitivamente simular ese comportamiento:  
`routes/index.js`

```js
const planets = require("./planets.json");

module.exports = {
  list: async () => {
    return planets;
  },
};
```

Completamos `getCharacters.js`:  
`getCharacters.js`

```js
const Characters = require("../data");

module.exports = async (req, res) => {
  const characters = await Characters.list();
  res.status(200).json(characters);
};
```

M√°s adelante vamos a ver una mejor forma de manejar errores que un `try...catch`.

Toda esta actividad la podemos replicar con `films` y `planets`.

## -------------------- **Fin clase** --------------------

<br>

## -------------------- **Clase** --------------------

Vamos a ver BUENAS PR√ÅCTICAS que debes cuidar para realizar con √©xito tu proyecto.

Cuando hacemos un pedido a una ruta `get`, no es muy buena pr√°ctica mandar la data plana.

Para empezar, voy a crear una carpeta `utils`.

Cuando hablamos de `utils` estamos hablando de una funci√≥n que va a hacer algo muy espec√≠fico, que puede ser un proceso que generalmente es sencillo, muy puntual, que puede ser algo como formatear un array, que reciba un dos strings y forme un objeto, etc., y que nosotros tranquilamente podr√≠amos reutilizarlas en otros proyectos. Me pregunto si es algo muy particular de mi proyecto, o yo me puedo llevar esta funci√≥n a otro proyecto y reutilizarla tambi√©n, eso ser√≠a un `utils`.

Un `helper` es algo m√°s espec√≠fico del proyecto que estoy trabajando.

Voy a crear un archivo `index.js` en la carpeta `utils`, donde voy a utilizar las funciones en `utils`:  
`utils/index.js`

```js
module.exports = {
  response: require("./response"),
};
```

Voy a crear `response.js` en `utils`. Queremos que esta funci√≥n se encargue de responder, de enviar la respuesta, que haga el `res.status‚Ä¶` y que cada vez que enviemos una respuesta reutilicemos esta funci√≥n. Las respuestas van a ser coherentes y van a cumplir con esta estructura. Podr√≠a enviar mas informaci√≥n, seg√∫n lo que necesite:  
`response.js`

```js
module.exports = (res, statusCode, data) => {
  res.status(statusCode).json({
    error: false,
    data,
  });
};
```

Agregamos a `getCharacters.js`, y `response` va a ser la funci√≥n que se encargue de elaborar esa respuesta:  
`getCharacters.js`

```js
const Planets = require("../data");
const { response } = require("../utils");

module.exports = async (req, res) => {
  const planets = await Planets.list();
  response(res, 200, planets);
};
```

Ahora empecemos a pensar el manejo de los errores.

Por ejemplo que al crear un personaje, ocurre un error:

```js
module.exports = (req, res) => {
  throw Error("Hubo un error");
  res.status(200).send("creando personaje");
};
```

Cuando nosotros hagamos la petici√≥n de tipo post a `characters`, me larga un error.
Hay varias cosas para marcar. Por un lado, la aplicaci√≥n no ha dejado de funcionar, me ha mostrado el `error`, pero ha logrado enviar la respuesta con un `error 500`, pero la aplicaci√≥n continua, no dejo de funcionar.

Distinto es cuando esta funci√≥n es `async`. De hecho, cuando lo tengamos listo, lo va a ser. Si hacemos ahora esta petici√≥n, la aplicaci√≥n se apag√≥:

```js
module.exports = async (req, res) => {
  throw Error("Hubo un error");
  res.status(200).send("creando personaje");
};
```

Una aplicaci√≥n creada con `Express` tiene un manejador de errores propio invisible, no lo escribimos nosotros, est√° ah√≠ en alg√∫n lugar. Y ahora vamos a ir a donde est√° y como lo podemos mejorar. Pero ese manejador de errores, va a tomar autom√°ticamente todos los errores que sean s√≠ncronos, es decir cualquier error de naturaleza sincr√≥nica que ocurra en nuestra aplicaci√≥n va a ser tomado autom√°ticamente por ese manejador de errores, y ese manejador de errores por defecto, va a responder con un `status 500` y va a enviar una traza del error que ha ocurrido.

Cuando los errores ocurran en operaciones o funciones de naturaleza as√≠ncrona, ese manejador de errores no logra capturar ese error y no logra manejarlo o al menos no autom√°ticamente, entonces nosotros tenemos como ayudarlo.

Continuemos agregando una funci√≥n `create`, en esta funci√≥n vamos a intentar de crear el personaje. Por el momento vamos a simular que estamos haciendo mal:  
`data/index.js`

```js
const characters = require("./characters.json");

module.exports = {
  list: async () => {
    return characters;
  },

  create: async () => {
    throw Error("Hay un error al momento de crear el personaje");
  },
};
```

Importamos el modelo al controlador:  
`createCharacter.js`

```js
const Characters = require("../data");
const { response } = require("../utils");

module.exports = async (req, res) => {
  const newCharacter = await Characters.create();
  response(res, 201, "Personaje creado.");
};
```

Ya sabemos que esto va a arrojar un error. Hasta ahora lo solucion√°bamos con un `try‚Ä¶catch`. El problema de esto es que el `try‚Ä¶catch` tiene que estar en todos lados. El problema es que cuando vayamos escalando, no queda muy legible.

Entonces en `index.js` de `utils` podemos crear una funci√≥n que se llame `catchedAsync` y creamos el modulo donde vamos aponer la funci√≥n:  
`utils/index.js`

```js
module.exports = {
  response: require("./response"),
  catchedAsync: require("./catchedAsync"),
};
```

Una forma de crear `catchedAsync.js` es que hagamos que una funci√≥n reciba el controlador en cuesti√≥n que nosotros queramos trabajar. Por ejemplo, que reciba el controlador `createCharacter`. Esta funci√≥n me va a retornar a su vez otra funci√≥n que va a recibir a `req`, `res` y `next`. Que al pasarle la funci√≥n de `createCharacter`, me reciba y me retorne una funci√≥n nueva, ejecute esta funci√≥n controladora el `controler`, pero que necesita el `controler` para funcionar, necesita `req` y `res`, entonces le pasamos `req` y `res`. Ahora si llegara a ocurrir este error y esta funci√≥n es as√≠ncrona y me esta dando una promesa, una buena manera de agarrar los errores de una promesa es con un `.catach()`. Este `catch` tiene el `error handler` y hago un `next` del `error`. Yo al hacer un `next` del error, tenemos un error, saltemos al manejador de errores de `Express`:  
`catchedAsync.js`

```js
module.exports = (fn) => {
  return function (req, res, next) {
    fn(req, res).catch((err) => {
      next(err);
    });
  };
};
```

A esta funci√≥n le damos un controlador y me da un controlador mejorado, que ya tiene el manejo de errores mejorado (funci√≥n de orden superior).

Agrego la funci√≥n `catchedAsync` al `index.js` de `controllers`:  
`controllers/index.js`

```js
const { catchedAsync } = require("../utils");

module.exports = {
  getCharacters: catchedAsync(require("./getCharacters")),
  createCharacter: catchedAsync(require("./createCharacter")),
};
```

De esta manera, no necesitamos escribir en ning√∫n controlador ni un solo `try‚Ä¶catch`.

El error ya esta manejado por el controlador de errores de `Express`.

Vamos a modificar el manejador de errores de Express, como vamos a prepararlo para los usos que queramos darles.

Podemos trabarlos en `server.js`, que si no ha encontrado un endpoint, que caiga en el controlador que nos va a dar el `404`:  
`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

server.use("*", (req, res) => {
  res.status(400).send("Not Found");
});

module.exports = server;
```

Para poder sobrescribir el manejador de errores de Express, vamos a crear una funci√≥n que va a recibir cuatro par√°metros: `err`, `req`, `res`, `next`. El hecho de que reciba estos cuatros par√°metros es lo que est√° indicando que estamos sobrescribiendo el manejador de errores de Express. O sea, un error que ocurra en cualquier lugar, deber√≠a llegar ac√°. Debemos prep√°ralo para que trabaje de la manera que nosotros queremos. No me tiene que enviar la traza del error, bajo ning√∫n concepto, al cliente. Expone un mont√≥n de informaci√≥n sensible sobre el funcionamiento de nuestro servicio:  
`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

server.use("*", (req, res) => {
  res.status(400).send("Not Found");
});

server.use((err, req, res, next) => {
  res.status(500).send(err.mesage);
});

module.exports = server;
```

El error que me pueda dar, no tiene por s√≠ mismo un `status code`. Vamos a tener que hacer una serie de modificaciones. Porque si bien es cierto que habr√° errores que no podremos manejar, ejemplo alg√∫n error en la base de datos, tendremos que manejarlo de alguna manera b√°sica. Pero si tengo un error porque el usuario no completo alg√∫n campo, no tengo que dejar que llegue al manejo b√°sico del error.

Entonces creo una carpeta `middlewares`, que va a estar el middleware, que va a validar las creaciones que queremos hacer, datos que queremos pedir, etc. Entonces nosotros nos aseguramos de que antes de que la funci√≥n `cr√©ate` por ejemplo, vaya a ser ejecutada, tenemos toda la informaci√≥n necesaria.

Vamos a crear dentro de la carpeta `middlewares` un archivo `index.js` y `characterValidation.js` que tiene una funci√≥n middleware. En esta funci√≥n, vamos a validar que la propiedad `name` sea v√°lido, sino que arroje un error:  
`middlewares/index.js`

```js
module.exports = {
  characterValidation: require("./characterValidation"),
};
```

`characterValidation.js`

```js
module.exports = (req, res, next) => {
  const { name } = req.body;
  if (name) return next();
  else throw Error("Falta el nombre del personaje");
};
```

A esta funci√≥n validadora la voy a tener que incluir en el siguiente lugar, antes de entrar siquiera al controlador, agrego el middlware, antes de llegar al controlador. Si algo llegara a ocurrir en le middleware, va a arrojar un error:

A esta funci√≥n validadora la voy a tener que incluir en el siguiente lugar, antes de entrar siquiera al controlador, agrego el middlware, antes de llegar al controlador. Si algo llegara a ocurrir en le middleware, va a arrojar un error:  
`routes/index.js`

```js
const { Router } = require("express");
const controllers = require("../controllers");
const middlewares = require("../middlewares");

const router = Router();

router.get("/", controllers.getCharacters);

router.post("/", middlewares.characterValidation, controllers.createCharacter);

module.exports = router;
```

Pero seguimos teniendo un problema, el manejador de error de Express me sigue respondiendo con un `500`.

Puedo crear dentro de `utils` una carpeta `errors`, y modifico el `idex.js` de `utils`:  
`utils/index.js`

```js
module.exports = {
  response: require("./response"),
  catchedAsync: require("./catchedAsync"),
  errors: require("./errors"),
};
```

Dentro de `errors` creo un `index.js`. Cuando arrojemos un error, tambi√©n queremos enviarle un `status code`. Lo hacemos creando una clase que extienda de `Error`:  
`utils/errors/index.js`

```js
class ClientError extends Error {
  constructor(message, statusCode = 400) {
    super(message);
    this.statusCode = statusCode;
  }
}

module.exports = { ClientError };
```

Modificamos nuestro `characterVailidation`:  
`characterVailidation.js`

```js
const { ClientError } = require("../utils/errors");

module.exports = (req, res, next) => {
  const { name } = req.body;
  if (name) return next();
  else throw new ClientError("Error en el nombre", 401);
};
```

Completo el `server.js`:  
`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

server.use("*", (req, res) => {
  res.status(400).send("Not Found");
});

server.use((err, req, res, next) => {
  res.status(err.statusCode || 500).send({
    error: true,
    message: err.message,
  });
});

module.exports = server;
```

Al final tenemos nuestro manejo de errores unificados.

## -------------------- **Fin clase** --------------------

<br>

## PASO 2

El siguiente paso que debemos dar es **crear el Gateway** que se encargue de recibir las peticiones y redirigirlas al servicio correspondiente. Para ello crearemos una aplicaci√≥n de Express sencilla, que tendr√° como √∫nica particularidad la instalaci√≥n de la librer√≠a [http-proxy-middleware](https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options/).

En t√©rminos sencillos, un **proxy** es una especie de **intermediario entre el cliente y el servidor**. La librer√≠a http-proxy-middleware permite crear un proxy en una aplicaci√≥n Node.js para que cuando un cliente env√≠e una solicitud, la solicitud sea primero enviada al proxy, y luego el proxy la reenv√≠a al servidor real.

Para ello entonces trabajaremos nuestro m√≥dulo index.js del gateway de la siguiente manera:

```js
const express = require("express");
const { createProxyMiddleware } = require("http-proxy-middleware");

const app = express();

app.use(
  "/characters",
  createProxyMiddleware({
    target: "http://localhost:8001",
    changeOrigin: true,
  })
);

app.listen(8000);
```

De esta manera, nuestro Gateway ya se encuentra escuchando en el puerto 8000 y redirigiendo las peticiones a ‚Äú/characters‚Äù hacia la aplicaci√≥n que escucha en el puerto 8001.

> Para la utilizaci√≥n de estos proxys, **NO ES RECOMENDABLE** iniciar la aplicaci√≥n con **Nodemon**. En su lugar, nuestro comando ‚Äústart‚Äù deber√° iniciar la aplicaci√≥n normalmente con node.

<br>

## -------------------- **Clase** --------------------

Vamos a crear el `gateway` que se encargara de redirigir las peticiones hacia el servicio que corresponda.

Creamos una carpeta `gateway`en la ra√≠z del proyecto.

Inciamos:

```bash
npm init -y
```

Instalamos las dependencias que necesitamos:

```bash
npm i express morgan http-proxy-middleware
```

Modificamos el `package.json`:

```json
{
  "scripts": {
    "start": "node index.js"
  },
}
```

Creamos un `index.js`:

```js
const express = require('express');
const morgan = require('morgan');
const { createProxyMiddleware } = require("http-proxy-middleware");

const app = express();

app.use(morgan("dev"));

app.use("/characters", createProxyMiddleware({
    target: "http://localhost:8001",
    changeOrigin: true,
    pathRewrite: {
      "^/characters": ""
    }
}));

app.use("/films", createProxyMiddleware({
    target: "http://localhost:8002",
    changeOrigin: true,
    pathRewrite: {
      "^/films": ""
    }
}));

app.use("/planets", createProxyMiddleware({
    target: "http://localhost:8003",
    changeOrigin: true,
    pathRewrite: {
      "^/planets": ""
    }
}));

app.listen(8000, () => {
    console.log('Gateway on port 8000')
});
```

La propiedad `target` es donde esta escuchando la aplicaci√≥n donde queremos que esto continue.

La propiedad `changeOrigin`, un poco le indica que ah√≠, va a modificar los headers de la request, y la request va a continuar hacia ese microservicio. 

La propiedad `pathRewrite` elimina la parte de la ruta correspondiente ("/characters", "/films", "/planets") antes de realizar la redirecci√≥n.

## -------------------- **Fin clase** --------------------
