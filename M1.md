# M贸dulo 1

# 驴Qu茅 aprenderemos?

- **Comprender la arquitectura de microservicios** y c贸mo se diferencia de la arquitectura monol铆tica.
- **Dise帽ar una aplicaci贸n** utilizando la arquitectura de microservicios.

<br>

# Introducci贸n a la arquitectura

**La arquitectura de microservicios** es un enfoque moderno para desarrollar y desplegar aplicaciones de software que se basa en la idea de construir aplicaciones como **un conjunto de servicios peque帽os, aut贸nomos y altamente escalables** que se ejecutan de forma independiente y se comunican entre s铆 a trav茅s de interfaces bien definidas.

> Cada microservicio se enfoca en una 煤nica funcionalidad o tarea espec铆fica y se puede desarrollar, desplegar y escalar de manera independiente, lo que permite una mayor flexibilidad y agilidad en el desarrollo de aplicaciones.

A diferencia de la **arquitectura monol铆tica**, donde todas las funcionalidades se encuentran integradas en una 煤nica aplicaci贸n, la arquitectura de microservicios promueve la divisi贸n de la aplicaci贸n en peque帽os servicios independientes que pueden ser desarrollados, desplegados y escalados de forma individual. **Cada microservicio se ejecuta en su propio entorno**, con su propia base de datos, configuraci贸n y recursos, lo que permite una mayor modularidad y autonom铆a.

![arquitectura](./assets/M1/arquitectura.jpg)

Una de las principales caracter铆sticas de la arquitectura de microservicios es la **comunicaci贸n a trav茅s de interfaces** bien definidas. Los microservicios se comunican entre s铆 a trav茅s de interfaces, como **API RESTful, mensajes asincr贸nicos o eventos**, lo que permite una mayor desacoplamiento entre los servicios y facilita la integraci贸n y evoluci贸n de la aplicaci贸n en el tiempo.

Adem谩s, la arquitectura de microservicios fomenta el uso de tecnolog铆as y herramientas que facilitan la automatizaci贸n, el monitoreo y la gesti贸n de los servicios, como contenedores, orquestadores, herramientas de descubrimiento de servicios, entre otros.

<br>

# Pros y contras

> Toda arquitectura de desarrollo de software tiene fortalezas (Pros), desventajas (Contras) y limitaciones dependiendo del contexto y objetivo del proyecto.

A continuaci贸n vamos a conocer cuales son las ventajas (Pros) de la arquitectura de microservicios:

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios permiten escalar cada servicio de forma independiente, lo que permite adaptar la capacidad de la aplicaci贸n a las necesidades espec铆ficas, optimizando el uso de recursos.
</details>

<details>
  <summary><b>Flexibilidad y agilidad</b></summary>
  
  Los microservicios facilitan la implementaci贸n de cambios y actualizaciones en la aplicaci贸n de manera r谩pida y aislada, sin afectar a otros servicios, lo que permite una mayor flexibilidad y agilidad en el desarrollo y despliegue de aplicaciones.
</details>

<details>
  <summary><b>Modularidad</b></summary>
  
  Los microservicios se enfocan en una 煤nica funcionalidad o tarea, lo que permite una mayor modularidad en el dise帽o y desarrollo de la aplicaci贸n. Esto facilita la reutilizaci贸n, el mantenimiento y la evoluci贸n de los servicios de forma individual.
</details>

<details>
  <summary><b>Independencia tecnol贸gica</b></summary>
  
  Cada microservicio puede utilizar diferentes tecnolog铆as, bases de datos y frameworks, lo que permite una mayor libertad en la elecci贸n de tecnolog铆as y herramientas adecuadas para cada servicio, sin estar limitado por una 煤nica tecnolog铆a en toda la aplicaci贸n.
</details>

<details>
  <summary><b>Desacoplamiento</b></summary>
  
  Los microservicios se comunican a trav茅s de interfaces bien definidas, lo que permite un bajo acoplamiento entre los servicios. Esto facilita la integraci贸n con otros sistemas y permite una mayor evoluci贸n y compatibilidad de la aplicaci贸n en el tiempo.
</details>  
  
<br>

Luego de conoces sus fortalezas, tambi茅n es fundamental conocer las **limitaciones o desventajas** de este tipo de arquitectura.

<details>
  <summary><b>Complejidad</b></summary>
  
  La gesti贸n de un sistema distribuido de microservicios puede ser compleja, ya que implica la orquestaci贸n, monitorizaci贸n y gesti贸n de m煤ltiples servicios en diferentes entornos.
</details>

<details>
  <summary><b>Mayor overhead</b></summary>
  
  La comunicaci贸n entre microservicios puede tener un overhead adicional, como la latencia de red y la necesidad de implementar mecanismos de seguridad y gesti贸n de errores en las interfaces de comunicaci贸n.
</details>

<details>
  <summary><b>Mayor esfuerzo de desarrollo inicial</b></summary>
  
  La construcci贸n de una arquitectura de microservicios puede requerir un mayor esfuerzo de desarrollo inicial para la creaci贸n y configuraci贸n de m煤ltiples servicios, infraestructuras de comunicaci贸n y herramientas de gesti贸n.
</details>

<details>
  <summary><b>Mayor complejidad en el despliegue</b></summary>
  
  El despliegue de microservicios puede requerir una mayor complejidad en la gesti贸n de la infraestructura, como el uso de herramientas de orquestaci贸n de contenedores y sistemas de descubrimiento de servicios.
</details>

<details>
  <summary><b>Reto en la gesti贸n de transacciones</b></summary>
  
  La gesti贸n de transacciones en una arquitectura de microservicios puede ser m谩s compleja, ya que las transacciones distribuidas pueden ser dif铆ciles de manejar entre diferentes servicios.
</details>

<br>

# Introducci贸n a Docker

> "Es una plataforma de virtualizaci贸n a nivel de sistema operativo que permite la creaci贸n, empaquetado y distribuci贸n de aplicaciones en contenedores. Los contenedores Docker son aislados y encapsulan todo lo necesario para que una aplicaci贸n se ejecute de manera consistente en cualquier entorno, independientemente de las diferencias en la infraestructura subyacente"  
> RedHat.com

### **En otras palabras, podemos decir que...**

Docker es una herramienta que te permite **empaquetar tu aplicaci贸n Node.js, junto con todas sus dependencias y configuraciones**, en un 'contenedor' port谩til. Este contenedor se asemeja a un caja virtual que contiene todo lo necesario para que tu aplicaci贸n Node.js funcione correctamente, incluyendo la versi贸n espec铆fica de Node.js, las bibliotecas y todos los paquetes de npm necesarios.

Imagina que tu aplicaci贸n Node.js es una casa con sus propios muebles y electrodom茅sticos. Docker ser铆a como una caja de mudanza que empaca todos los elementos necesarios para tu casa en un solo lugar, de manera ordenada y segura. Luego, puedes llevar esa caja de mudanza a cualquier lugar, como un nuevo servidor o el entorno de desarrollo de tu colega, y asegurarte de que todos los elementos de tu casa est茅n en su lugar correcto y funcionando sin problemas.

[En el siguiente video  podr谩s conocer la importancia de Docker y su potencial](https://www.youtube.com/watch?v=-bS36SMr2Yw)

Adem谩s de los beneficios comentados en el video anterior, **Docker** es una herramienta extremadamente 煤til al **trabajar con microservicios** por varias razones que detallamos a continuaci贸n:

<details>
  <summary><b>Independencia de dependencias</b></summary>
  
  Los microservicios suelen ser peque帽as aplicaciones o componentes de una aplicaci贸n m谩s grande que se ejecutan de forma independiente. Cada microservicio puede tener sus propias dependencias y configuraciones espec铆ficas. Docker permite empaquetar cada microservicio junto con sus dependencias en un contenedor independiente. Esto asegura que cada microservicio tenga su propio entorno aislado y no se vea afectado por las dependencias de otros microservicios o del sistema operativo en el que se ejecutan.
</details>

<details>
  <summary><b>Portabilidad</b></summary>
  
  Docker permite empaquetar un microservicio y todas sus dependencias en un contenedor, lo que lo hace altamente port谩til. Puedes mover f谩cilmente el contenedor de un entorno a otro, como de desarrollo a producci贸n, o entre diferentes servidores o plataformas en la nube. Esto facilita la implementaci贸n y despliegue de microservicios en diferentes entornos sin preocuparse por las diferencias en la configuraci贸n del sistema operativo o las dependencias.
</details>

<details>
  <summary><b>Escalabilidad</b></summary>
  
  Los microservicios suelen dise帽arse para escalar horizontalmente, lo que significa que se pueden ejecutar varias instancias del mismo microservicio para manejar cargas de trabajo crecientes. Docker facilita la replicaci贸n y el escalado de microservicios al permitir la creaci贸n de m煤ltiples contenedores a partir de la misma imagen de Docker. Esto hace que sea sencillo agregar o quitar instancias de microservicios seg煤n sea necesario para adaptarse a los cambios en la demanda.
</details>

<details>
  <summary><b>Consistencia y reproducibilidad</b></summary>
  
  Docker asegura que los microservicios se ejecuten de la misma manera en todos los entornos, lo que garantiza la consistencia en el desarrollo, prueba y producci贸n. Adem谩s, Docker permite definir la configuraci贸n del contenedor en un archivo llamado Dockerfile, lo que facilita la reproducci贸n del entorno de ejecuci贸n del microservicio en diferentes etapas del ciclo de vida del desarrollo de software, desde el desarrollo local hasta la producci贸n.
</details>

<details>
  <summary><b>Facilidad en la gesti贸n</b></summary>
  
  Docker proporciona una interfaz de l铆nea de comandos y una interfaz gr谩fica de usuario que facilita la gesti贸n de los contenedores de microservicios. Puedes iniciar, detener, reiniciar o eliminar contenedores con simples comandos o acciones de interfaz gr谩fica. Adem谩s, Docker tiene una amplia comunidad y un ecosistema de herramientas y servicios que facilitan la gesti贸n y monitoreo de microservicios.
</details>

<br>

# Instalaci贸n de Docker

Luego de conocer los beneficios de Docker, vamos a **instalar la aplicaci贸n** en tu sistema operativo.

[En el siguiente video podr谩s conocer como instalar Docker en Windows](https://www.youtube.com/watch?v=BK-C2RofmTE&t=16s)

Luego de instalar Docker correctamente, vamos explorar c贸mo crear un Aplicaci贸n de NodeJS en Docker.

[Enlace](https://www.youtube.com/watch?v=iLlmm0L-VpQ&t=47s)

En el video anterior se demostr贸 como crear una aplicaci贸n sencilla en Docker, ahora vamos a poner manos a la obra para comenzar con nuestra primera **Homework**.

<br>

# Proyecto Star Wars API

Para esta actividad deber谩s contar con este [repositorio](https://github.com/soyHenry/be-ct-upskilling-microservicios) (o la carpeta repositorio), ser谩 la base de lo que estaremos creando. Este proyecto se trata de una **API de Star Wars**, que maneja informaci贸n sobre los personajes de la franquicia (Characters), las pel铆culas que se han lanzado (Films) y los planetas que aparecen en dichas pel铆culas (Planets).

Podr谩s notar que este repositorio contiene un proyecto de **Nodejs** similar a los que ya has desarrollado durante la carrera:

1. Un servidor web HTTP creado con la librer铆a Express.
2. Un enrutador al cual el servidor le delega el enrutado de la aplicaci贸n.
3. Tres (3) routers que se encargan de definir rutas para cada una de las entidades que trabajamos (Films, Characters y Planets).
4. Los controladores de las rutas no se comunican (por el momento) con ninguna Base de Datos, sino que obtienen los datos a partir de unos archivos Json que contienen los registros para cada una de las entidades.

![repositorio](./assets/M1/repositorio.jpg)

![starwars api](./assets/M1/star_wars_api.png)

Te dejamos adem谩s un vistazo del **package.json** que posee hasta el momento con las dependencias instaladas. Por el momento **no necesitaremos m谩s dependencias que estas**.

![package.json](./assets/M1/package_json.png)

Tanto la estructura del proyecto como las funcionalidades que posee hasta el momento son las que ya conocemos. Esta aplicaci贸n, como ver谩s, se ajusta a la **estructura monol铆tica** que vimos en pasos anteriores:

- Cuenta con una 煤nica aplicaci贸n de Express que se encarga de manejar todo el servicio.
- Toda la aplicaci贸n se expone en un 煤nico puerto del host donde se encuentre.
- Si bien la l贸gica de negocio de la aplicaci贸n se ir谩 definiendo en rutas y enrutadores distintos, al final del camino todo forma parte de una 煤nica aplicaci贸n.

## -------------------- **Clase** --------------------

El objetivo es poder hacer que toda la l贸gica este dividida en microservicios. Cuando hablamos de microservicios, estamos hablando de peque帽as aplicaciones de Express en nuestro caso.

Nuestro objetivo es poder hacer que tengamos tres aplicaciones peque帽as, una que se encargue de gestionar la informaci贸n de los personajes, otra que se encargue de gestionar la informaci贸n de las pel铆culas y otra de los planetas.

Los controladores de las rutas, manejan los datos de un json, m谩s adelante lo pasaremos a una base de datos. Vamos a ver que la gesti贸n de los datos en la base de datos, tambi茅n sea un microservicio aparte.

## -------------------- **Fin clase** --------------------

<br>

# HW 1 - Actividad 1

Esta primera Homework est谩 estructurada en dos actividades con objetivos muy espec铆ficos:

## Actividad 1

Debes lograr **dividir esta aplicaci贸n en aplicaciones m谩s peque帽as y sencillas**, que involucren un 煤nico aspecto, entidad o funcionalidad del proyecto.

El objetivo es dividir nuestro proyecto en una estructura similar a la siguiente:

![starwars api](./assets/M1/star_wars_api2.png)

Como podr谩s ver , contaremos con una **API Gateway** que se encargar谩 de redirigir las peticiones al servicio que corresponda seg煤n la petici贸n. Este gateway no es m谩s que una aplicaci贸n de Express que escuchar谩 las peticiones en un puerto de tu host.

A su vez, **cada uno de estos servicios ser谩 una aplicaci贸n de Express individual**, que estar谩 escuchando peticiones en un puerto distinto y que contar谩 tambi茅n con sus capas (capa de enrutado, capa de controladores, capa de datos "por el momento los .json").

Respecto a c贸mo la API Gateway redirigir谩 las peticiones, lo har谩 realizando nuevas peticiones HTTP a los host:port donde est茅n escuchando cada uno de los dem谩s servicios.

De esta manera, el cliente realizar谩 sus peticiones **NICAMENTE al API Gateway**, y ser谩 este quien se encargue de comunicarse con los microservicios involucrados en cada petici贸n.

> Para llevar adelante esta actividad te recomendamos que **inicies una nueva carpeta** dentro de la cual podr谩s trabajar cada uno de los proyectos de Node por separado. Puedes incluir cualquier dependencia que quieras o creas necesaria aparte de las propuestas en el package.json original.

<br>

## 隆Debemos ir por partes! (PASO 1)

Como primer paso es recomendable **separar para cada una de las entidades que estamos manejando una aplicaci贸n de Express diferente**. Cada una de ellas contar谩 con la estructura b谩sica ya conocida de las aplicaciones de esta naturaleza.

Para este paso es recomendable trabajar cada una de las aplicaciones como algo totalmente independiente del resto de la estructura. Como si estuvieras haciendo una Rest API s煤per sencilla que maneja datos de una 煤nica entidad.

Al final de este paso deber铆as tener algo similar a lo siguiente:

![estructura carpetas](./assets/M1/estructura_carpetas.jpg)

![escuchando puertos](./assets/M1/escuchando_puertos.jpg)

## -------------------- **Clase** --------------------

Iniciamos el proyecto.

Vamos a crear el servicio de `characters`. Lo mismo hay que hacer con los otros servicios.

Iniciamos el proyecto:

```bash
npm init -y
```

Voy creando la carpeta `src` y el archivo `index.js`. Tambi茅n voy instalando algunas dependencias:

```bash
npm i express morgan
```

Creamos el archivo `server.js` dentro de la carpeta `src` donde creamos nuestro servidor de Express:  
`server.js`

```js
const express = require("express");

const server = express();

module.exports = server;
```

Completamos el archivo `index.js` y lo pongamos a escuchar en el puerto `8001` y los otros servicios lo puedo poner a escuchar en el puerto `8002` y `8003` respectivamente:  
`index.js`

```js
const server = require("./src/server");

const PORT = 8001;

server.listen(PORT, () => {
  console.log(`Characters service listening on port ${PORT}`);
});
```

Agregamos `nodemon`:

```bash
npm i nodemon -D
```

Modificamos el archivo `package.json`:  
`package.json`

```json
{
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  }
}
```

Ahora lo podemos correr:

```bash
npm run dev
```

Creo una carpeta `data` y `routes` dentro de `src` para ir estructurando.

Vamos a seguir configurando `server.js`:

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

module.exports = server;
```

Creamos un archivo `index.js` en la carpeta `routes` y lo vamos completando, para que el `server.js` pueda requerirlo y a partir de all铆 empezar a delegar este servicio:  
`routes/index.js`

```js
const { Router } = require("express");

const router = Router();

module.exports = router;
```

`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(morgan("dev"));
server.use(express.json());

server.use(require("./routes"));

module.exports = server;
```

Ahora vamos a ver la estructura o las capas que le vamos a dar cuando vayan pasando nuestra `requests`.

Si el `gateway` ha hecho llegar la `request` al microservicio de `characters`, es por que ya es de `characters`.

Voy a crear un controlador, que es la funci贸n que administra la l贸gica, donde esta volcada toda la l贸gica de negocio para alg煤n endpoint en particular.

Por eso lo m谩s recomendable, es trabajar con una carpeta de `controllers`, la creamos, para que podamos tener todas las funciones definidas en otros m贸dulos.

Es bastante recomendable crear en la carpeta `controllers`, un archivo `index.js`, que va a ser el 铆ndice de todos los controladores que haya en esta carpeta:  
`controllers/index.js`

```js
module.exports = {
  getCharacters: require("./getCharacters"),
  createCharacter: require("./createCharacter"),
};
```

Creamos `getCharacters.js` y `createCharacter.js`:  
`controllers/getCharacters.js`

```js
module.exports = (req, res) => {
  res.status(200).send("personajes");
};
```

`controllers/createCharacter.js.js`

```js
module.exports = (req, res) => {
  res.status(200).send("creando personaje");
};
```

Agregamos en el `index.js` de la carpeta `routes`, indicandoles las `callback` que se ejecuta en cada endponint:  
`routes/index.js`

```js
const { Router } = require("express");
const controllers = require("../controllers");

const router = Router();

router.get("/", controllers.getCharacters);

router.post("/", controllers.createCharacter);

module.exports = router;
```

Esta forma de trabajar, tiene una gran ventaja en el manejo de errores. Si trabajamos de forma correcta y bien modularizada, podemos tener un manejo de errores teniendo un c贸digo que se encargue de esto y sea eficiente.

Dentro de la carpeta `data`, deber铆amos tener el `character.json`, sino lo traemos de la carpeta original de cuando empezamos la actividad.

Vamos a empezar a usar este archivo `json`, ya que no tenemos una base de datos real.

Vamos a empezar a crear la capa de datos de este microservicio.

Vamos a crear un archivo `index.js` dentro de la carpeta `data` para traer el `json`. Vamos a definir unas funciones que simulara ser el modelo. La funci贸n `list` retorna los personajes que hay en el `json`. Ahora lo saca de `json`, pero m谩s adelante lo puede sacar de una base de datos, de un array, etc:

Ahora lo usamos en `getCharacters`, que lo utiliza como si fuera un modelo m谩s, que podr铆a ser de una base de datos, pero es un modelo de mentira, pero que est谩 funcionando. Lo que logro es que ya pueda dejar planteado del lado del controlador cual es el c贸digo con el que despu茅s voy a usar en la base de datos. `Character` luego ser谩 un modelo de una base de datos no relacional, pero cuando eso cambie, el controlador no va a cambiar absolutamente en nada.
Y para asegurarnos que no cambie, le voy a decir que funci贸n `list` sea as铆ncrona, para que ya definitivamente simular ese comportamiento:  
`routes/index.js`

```js
const planets = require("./planets.json");

module.exports = {
  list: async () => {
    return planets;
  },
};
```

Completamos `getCharacters.js`:  
`getCharacters.js`

```js
const Characters = require("../data");

module.exports = async (req, res) => {
  const characters = await Characters.list();
  res.status(200).json(characters);
};
```

M谩s adelante vamos a ver una mejor forma de manejar errores que un `try...catch`.

Toda esta actividad la podemos replicar con `films` y `planets`.

## -------------------- **Fin clase** --------------------

<br>

## -------------------- **Clase** --------------------

Vamos a ver BUENAS PRCTICAS que debes cuidar para realizar con 茅xito tu proyecto.

Cuando hacemos un pedido a una ruta `get`, no es muy buena pr谩ctica mandar la data plana.

Para empezar, voy a crear una carpeta `utils`.

Cuando hablamos de `utils` estamos hablando de una funci贸n que va a hacer algo muy espec铆fico, que puede ser un proceso que generalmente es sencillo, muy puntual, que puede ser algo como formatear un array, que reciba un dos strings y forme un objeto, etc., y que nosotros tranquilamente podr铆amos reutilizarlas en otros proyectos. Me pregunto si es algo muy particular de mi proyecto, o yo me puedo llevar esta funci贸n a otro proyecto y reutilizarla tambi茅n, eso ser铆a un `utils`.

Un `helper` es algo m谩s espec铆fico del proyecto que estoy trabajando.

Voy a crear un archivo `index.js` en la carpeta `utils`, donde voy a utilizar las funciones en `utils`:  
`utils/index.js`

```js
module.exports = {
  response: require("./response"),
};
```

Voy a crear `response.js` en `utils`. Queremos que esta funci贸n se encargue de responder, de enviar la respuesta, que haga el `res.status` y que cada vez que enviemos una respuesta reutilicemos esta funci贸n. Las respuestas van a ser coherentes y van a cumplir con esta estructura. Podr铆a enviar mas informaci贸n, seg煤n lo que necesite:  
`response.js`

```js
module.exports = (res, statusCode, data) => {
  res.status(statusCode).json({
    error: false,
    data,
  });
};
```

Agregamos a `getCharacters.js`, y `response` va a ser la funci贸n que se encargue de elaborar esa respuesta:  
`getCharacters.js`

```js
const Planets = require("../data");
const { response } = require("../utils");

module.exports = async (req, res) => {
  const planets = await Planets.list();
  response(res, 200, planets);
};
```

Ahora empecemos a pensar el manejo de los errores.

Por ejemplo que al crear un personaje, ocurre un error:

```js
module.exports = (req, res) => {
  throw Error("Hubo un error");
  res.status(200).send("creando personaje");
};
```

Cuando nosotros hagamos la petici贸n de tipo post a `characters`, me larga un error.
Hay varias cosas para marcar. Por un lado, la aplicaci贸n no ha dejado de funcionar, me ha mostrado el `error`, pero ha logrado enviar la respuesta con un `error 500`, pero la aplicaci贸n continua, no dejo de funcionar.

Distinto es cuando esta funci贸n es `async`. De hecho, cuando lo tengamos listo, lo va a ser. Si hacemos ahora esta petici贸n, la aplicaci贸n se apag贸:

```js
module.exports = async (req, res) => {
  throw Error("Hubo un error");
  res.status(200).send("creando personaje");
};
```

Una aplicaci贸n creada con `Express` tiene un manejador de errores propio invisible, no lo escribimos nosotros, est谩 ah铆 en alg煤n lugar. Y ahora vamos a ir a donde est谩 y como lo podemos mejorar. Pero ese manejador de errores, va a tomar autom谩ticamente todos los errores que sean s铆ncronos, es decir cualquier error de naturaleza sincr贸nica que ocurra en nuestra aplicaci贸n va a ser tomado autom谩ticamente por ese manejador de errores, y ese manejador de errores por defecto, va a responder con un `status 500` y va a enviar una traza del error que ha ocurrido.

Cuando los errores ocurran en operaciones o funciones de naturaleza as铆ncrona, ese manejador de errores no logra capturar ese error y no logra manejarlo o al menos no autom谩ticamente, entonces nosotros tenemos como ayudarlo.

Continuemos agregando una funci贸n `create`, en esta funci贸n vamos a intentar de crear el personaje. Por el momento vamos a simular que estamos haciendo mal:  
`data/index.js`

```js
const characters = require("./characters.json");

module.exports = {
  list: async () => {
    return characters;
  },

  create: async () => {
    throw Error("Hay un error al momento de crear el personaje");
  },
};
```

Importamos el modelo al controlador:  
`createCharacter.js`

```js
const Characters = require("../data");
const { response } = require("../utils");

module.exports = async (req, res) => {
  const newCharacter = await Characters.create();
  response(res, 201, "Personaje creado.");
};
```

Ya sabemos que esto va a arrojar un error. Hasta ahora lo solucion谩bamos con un `trycatch`. El problema de esto es que el `trycatch` tiene que estar en todos lados. El problema es que cuando vayamos escalando, no queda muy legible.

Entonces en `index.js` de `utils` podemos crear una funci贸n que se llame `catchedAsync` y creamos el modulo donde vamos aponer la funci贸n:  
`utils/index.js`

```js
module.exports = {
  response: require("./response"),
  catchedAsync: require("./catchedAsync"),
};
```

Una forma de crear `catchedAsync.js` es que hagamos que una funci贸n reciba el controlador en cuesti贸n que nosotros queramos trabajar. Por ejemplo, que reciba el controlador `createCharacter`. Esta funci贸n me va a retornar a su vez otra funci贸n que va a recibir a `req`, `res` y `next`. Que al pasarle la funci贸n de `createCharacter`, me reciba y me retorne una funci贸n nueva, ejecute esta funci贸n controladora el `controler`, pero que necesita el `controler` para funcionar, necesita `req` y `res`, entonces le pasamos `req` y `res`. Ahora si llegara a ocurrir este error y esta funci贸n es as铆ncrona y me esta dando una promesa, una buena manera de agarrar los errores de una promesa es con un `.catach()`. Este `catch` tiene el `error handler` y hago un `next` del `error`. Yo al hacer un `next` del error, tenemos un error, saltemos al manejador de errores de `Express`:  
`catchedAsync.js`

```js
module.exports = (fn) => {
  return function (req, res, next) {
    fn(req, res).catch((err) => {
      next(err);
    });
  };
};
```

A esta funci贸n le damos un controlador y me da un controlador mejorado, que ya tiene el manejo de errores mejorado (funci贸n de orden superior).

Agrego la funci贸n `catchedAsync` al `index.js` de `controllers`:  
`controllers/index.js`

```js
const { catchedAsync } = require('../utils')

module.exports = {
    getCharacters: catchedAsync(require("./getCharacters")),
    createCharacter: catchedAsync(require("./createCharacter"))
}
```

De esta manera, no necesitamos escribir en ning煤n controlador ni un solo `trycatch`.

## -------------------- **Fin clase** --------------------
