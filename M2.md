# M√≥dulo 2

<br>

# ¬øQu√© aprenderemos?

- **Integrar** una Base de Datos No SQL, como MongoDB, en una arquitectura de microservicios.
- **Crear** y **configurar** un cluster de datos de MongoDB en [MongoDB Atlas](https://www.mongodb.com/), utilizando las herramientas disponibles en la capa gratuita.
- **Delegar** la comunicaci√≥n de datos a un microservicio especializado, separando as√≠ la l√≥gica de las consultas a la Base de Datos de los dem√°s microservicios.
- **Utilizar** la librer√≠a [Mongoose ](https://mongoosejs.com/) para comunicarte con la Base de Datos MongoDB desde Javascript.

<br>

# Introducci√≥n a Bases de datos No SQL

Una **base de datos NoSQL**, tambi√©n conocida como base de datos NoSQL (Not Only SQL), es un tipo de base de datos dise√±ada para almacenar y recuperar grandes vol√∫menes de datos no estructurados o semi-estructurados.

> Estas bases de datos son ampliamente utilizadas en aplicaciones modernas que requieren un alto rendimiento, como aplicaciones web, sistemas de gesti√≥n de contenido, aplicaciones de Big Data y IoT (Internet de las cosas), entre otros. Algunos ejemplos populares de bases de datos NoSQL incluyen MongoDB, Cassandra, Redis, Couchbase y Neo4j.

A diferencia de las bases de datos SQL tradicionales, las bases de datos NoSQL no utilizan el lenguaje SQL para consultar y manipular los datos, sino que **emplean diferentes modelos de datos**, como el modelo de documentos, el modelo de columnas, el modelo clave-valor o el modelo de grafos.

## SQL vs. NoSQL

Mira con atenci√≥n la siguiente tabla para atender a las diferencias entre estos dos modelos de base de datos.

|                          | SQL                                                                                             | NoSQL                                                                                                                                       |
| ------------------------ | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Estructura de datos      | Utiliza tablas y filas estructuradas                                                            | Utiliza diversos modelos de datos estructurados o no estructurados                                                                          |
| Escalabilidad            | Verticalmente escalable (escalado hacia arriba, m√°s potencia en el servidor)                    | Horizontalmente escalable (escalado hacia fuera, agregando m√°s servidores)                                                                  |
| Esquema                  | Define un esquema r√≠gido antes de almacenar los datos                                           | No requiere un esquema fijo, lo que permite flexibilidad en la estructura de los datos                                                      |
| Consultas                | Utiliza SQL para consultas y manipulaci√≥n de datos                                              | Utiliza modelos de consulta espec√≠ficos seg√∫n el modelo de datos (p. ej., consultas basadas en documentos, consultas de b√∫squeda de claves) |
| Transacciones            | Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad)                 | Algunas bases de datos NoSQL admiten transacciones, pero no todas                                                                           |
| Escalabilidad horizontal | Menos adecuado para grandes vol√∫menes de datos y cargas de trabajo escalables horizontalmente   | M√°s adecuado para grandes vol√∫menes de datos y cargas de trabajo escalables horizontalmente                                                 |
| Flexibilidad             | Menos flexible en t√©rminos de cambios en el esquema y adaptabilidad a diferentes tipos de datos | Mayor flexibilidad para manejar cambios en la estructura de los datos y adaptarse a diferentes tipos de datos                               |
| Madurez y adopci√≥n       | Largo historial de desarrollo y amplia adopci√≥n en la industria                                 | Relativamente m√°s reciente y menos adopci√≥n generalizada en comparaci√≥n con las bases de datos SQL                                          |
| Ejemplos                 | MySQL, PostgreSQL, Oracle                                                                       | MongoDB, Cassandra, Redis, CouchDB, Neo4j                                                                                                   |

<br>

# ¬øPor qu√© NoSQL y microservicios?

> Las Bases de Datos No SQL suelen ser m√°s apropiadas en algunos sistemas de microservicios por varias razones.
> ¬°Conozcamos cada una de ellas!

<details>
  <summary><b>Escalabilidad horizontal</b></summary>
  
  Las bases de datos NoSQL est√°n dise√±adas para escalar horizontalmente, lo que significa que puedes agregar m√°s nodos o servidores para manejar el aumento de la carga de trabajo.

Esto es especialmente importante en una arquitectura de microservicios, donde cada microservicio puede tener su propia base de datos y necesitar una capacidad de escalado independiente.

Las bases de datos NoSQL facilitan la distribuci√≥n y partici√≥n de datos entre m√∫ltiples nodos, permitiendo un escalado m√°s eficiente.

</details>

<details>
  <summary><b>Esquema flexible</b></summary>
  
  En una arquitectura de microservicios, los microservicios pueden evolucionar de forma independiente y tener diferentes requisitos de datos. Una base de datos NoSQL proporciona una mayor flexibilidad en t√©rminos de cambios en el esquema, lo que facilita la adici√≥n, modificaci√≥n o eliminaci√≥n de atributos de datos sin afectar a otros microservicios.

Esto es especialmente √∫til cuando se trabaja en un entorno √°gil o se necesita una r√°pida adaptaci√≥n a los cambios en los requerimientos del sistema.

</details>

<details>
  <summary><b>Modelo de datos adecuado</b></summary>
  
  Las bases de datos NoSQL ofrecen diferentes modelos de datos, como documentos, columnas, claves-valor y grafos. Estos modelos se ajustan bien a diferentes tipos de microservicios y escenarios de uso.

Por ejemplo, una base de datos de documentos como MongoDB es adecuada para almacenar datos semiestructurados, mientras que una base de datos de grafos como Neo4j es √∫til para representar relaciones complejas entre los datos. Puedes seleccionar el modelo de datos m√°s adecuado para cada microservicio seg√∫n sus necesidades espec√≠ficas.

</details>

<details>
  <summary><b>Rendimiento y velocidad</b></summary>
  
  Las bases de datos NoSQL est√°n optimizadas para consultas r√°pidas y operaciones de escritura eficientes. En una arquitectura de microservicios, donde los microservicios se ejecutan de forma independiente y deben responder r√°pidamente a las solicitudes, una base de datos NoSQL puede ofrecer un rendimiento superior.

Adem√°s, algunos modelos de bases de datos NoSQL, como las bases de datos en memoria (como Redis), proporcionan una latencia extremadamente baja y son ideales para casos de uso donde la velocidad es cr√≠tica.

</details>

<details>
  <summary><b>Adaptabilidad a la escala y la variedad</b></summary>
  
  En una arquitectura de microservicios, los microservicios pueden tener diferentes cargas de trabajo y requerir diferentes tipos de almacenamiento de datos.

Las bases de datos NoSQL ofrecen una variedad de opciones de almacenamiento, como bases de datos de alto rendimiento en memoria, almacenamiento en cach√© distribuido y almacenamiento masivo en disco. Esto permite adaptar el almacenamiento de datos seg√∫n las necesidades espec√≠ficas de cada microservicio y escalarlos individualmente.

</details>

<br>

# Introducci√≥n a Mongo DB y Mongo DB Atlas

## ¬øQu√© es Mongo DB?

> MongoDB es una base de datos NoSQL orientada a documentos, lo que significa que almacena los datos en forma de documentos similares a JSON en lugar de utilizar tablas y filas como las bases de datos relacionales tradicionales.

### Algunas de sus caracter√≠sticas...

1. Fue desarrollada con el objetivo de brindar escalabilidad, flexibilidad y rendimiento en entornos de aplicaciones modernas.
2. Utiliza un modelo de datos flexible y din√°mico, lo que permite almacenar datos con estructuras variables dentro de un mismo conjunto de datos. Esto significa que no se requiere un esquema fijo y predefinido, lo que facilita la iteraci√≥n y evoluci√≥n de las aplicaciones.
3. Permite distribuir la carga de trabajo en m√∫ltiples servidores y manejar grandes vol√∫menes de datos. Esto es especialmente √∫til en aplicaciones con altas demandas de rendimiento y escalabilidad.
4. Ofrece una amplia gama de caracter√≠sticas y funcionalidades, como √≠ndices flexibles, consultas ad hoc poderosas, replicaci√≥n autom√°tica para alta disponibilidad, fragmentaci√≥n de datos (sharding) para distribuir la carga y tolerancia a fallos, y soporte para operaciones geoespaciales.
5. Se utiliza en una variedad de aplicaciones y casos de uso, desde aplicaciones web y m√≥viles hasta sistemas de gesti√≥n de contenido, an√°lisis de datos, IoT y muchas otras √°reas donde la flexibilidad y el rendimiento son fundamentales.

## ¬øQu√© Mongo DB Atlas?

> MongoDB Atlas es un servicio de base de datos en la nube ofrecido por MongoDB. Proporciona una forma f√°cil y conveniente de alojar, administrar y escalar cl√∫steres de bases de datos MongoDB en entornos en la nube, sin tener que preocuparse por la configuraci√≥n y el mantenimiento de la infraestructura subyacente.

### Algunas de sus caracter√≠sticas...

1. Los usuarios pueden crear cl√∫steres de bases de datos MongoDB con unos pocos clics.
2. El servicio se encarga de aspectos como aprovisionamiento de hardware, configuraci√≥n de la red, configuraci√≥n de seguridad y respaldo de datos.
3. Permite a los desarrolladores centrarse en el desarrollo de sus aplicaciones en lugar de preocuparse por la administraci√≥n de la infraestructura.

<br>

# ¬°Manos a la obra!

> üëÄ Para poder continuar con nuestra actividad, utilizaremos como BDD No-SQL a MongoDB.

### Recordemos...

**MongoDB** es una base de datos NoSQL orientada a documentos. En lugar de utilizar tablas y filas como en las bases de datos SQL tradicionales, MongoDB almacena los datos en documentos BSON (Binary JSON).

Esta base de datos no la trabajaremos de forma local, sino que estar√° alojada en un cluster de **MongoDB Atlas**. Este es un servicio de base de datos en la nube ofrecido por MongoDB. Es una plataforma de base de datos como servicio (DBaaS) que permite a los usuarios desplegar, gestionar y escalar cl√∫steres de bases de datos MongoDB en la nube de forma sencilla y que posee adem√°s una capa gratuita bastante robusta.

En el siguiente video podr√°s ver el paso a paso para la creaci√≥n de un cluster en MongoDB Atlas y a partir de all√≠ empezar a crear tu Base de Datos.

[Video](https://www.youtube.com/watch?v=J61_hiFauNs)

En el video anterior se demostr√≥ como crear un cluster para crear a partir de all√≠ nuestra BDD.

<br>

# HW 2 parte I

> En esta actividad nos centraremos en la creaci√≥n de un microservicio dedicado exclusivamente a la conexi√≥n e interacci√≥n con nuestra base de datos.

Al finalizar esta actividad, tendremos una arquitectura similar a la siguiente:

![Star Wars API](./assets/M2/star_wars_api3.png)

Ten en cuenta que para poder iniciar con esta actividad, es importante que hayas generado correctamente tu cluster de datos en MongoDB Atlas.

Adem√°s, debes haber instalado en tu computadora MongoDB Compass. Esta herramienta nos servir√° para poder precargar los datos que ya tenemos de forma s√∫per sencilla, y sin tener que estar generando scripts a mano para este proceso.

## ¬°Comencemos!

### **1**

En esta primera parte, crearemos con la ayuda de **MongoDB Compass** la Base de Datos de nuestro proyecto.

Luego, importamos los datos que ya tenemos guardados en nuestros archivos JSON. De esta manera, de forma muy sencilla y sin tener que desarrollar scripts, podremos tener la precarga terminada en nuestra Base de Datos y estar listos para continuar.

### ------------------------------ **Clase** ------------------------------

Ya tengo que tener creado nuestro Cluster de MongoDB Atlas y haber descargado MongoDB Compass, para hacer la precarga de los datos que necesitamos para poder trabajar.

### En MongoDB Atlas

Voy a **Database Access** y cuando lleguemos ya vamos a tener un usuario Creado al momento de crear el cl√∫ster, que tiene una contrase√±a que se guenera aleatoriamente y a veces no la anotamos y no la podemos recupera y tenemos que reiniciar la contrase√±a.

Entonces lo mejor es crear un usuario.

Ahora voy a **Network Access**, Qu√© cuando entro veo escrita mi IP, La puedo editar y cambiar la por `0.0.0.0/0`, Que esto significa que podemos conectar a nuestro cl√∫ster desde cualquier IP. El principio es aconsejable dejarlode esta forma, luego la podemos cambiar cuando nuestra aplicaci√≥n este desplegada.

Luego voy a **Database** y hacemos click en **Connect**. Nos da opciones de c√≥mo nos queremos conectar. Elegimos la opci√≥n de **Compass**, Y nos va a dar una URL, la vamos a copiar y a pasar a **MongoDB Compass**.

### En MongoDB Compass

Pego la URL donde dice **URI**. Tengo que cambiar el `user` y el `password` y hago click en **Connect**. Y MongoDB Compass se va a conectar con nuestro cl√∫ster.

Voy a **Database**, hago click en **Create database** y le llamos `star_wars`, nos va a pedir el nombre de una primera colecci√≥n, que ser√≠a como una primera tabla, Que en realidad ser√≠an colecciones, y le llamo `characters`.

Antes de importar Tengo que entrar al archivo `json` y cambiar los `id` por `_id`, por que MongoDB Atlas le llama as√≠ a los id.

Entro a la base de datos y en `characters` hago clic en **Import Data**.

Ya tengo cargado toda la informaci√≥n que tenia en nuestro archivo `json`, en la colecci√≥n `characters`. Hago lo mismo con `films` y `planets`.

### ------------------------------ **Fin clase** ------------------------------

## 2

Para esta segunda parte, crearemos una **aplicaci√≥n de Express** sencilla y convencional con la estructura b√°sica que ya conocemos:

- Un ‚Äúindex.js‚Äù como entry point de la aplicaci√≥n
- Un servidor de Express que escuchar√° en el puerto 8004
- Un enrutador sencillo que por el momento dejaremos en suspenso qu√© rutas definir√°.

A partir de all√≠, comenzaremos a crear nuestra conexi√≥n con la base de datos y a definir los modelos que necesitaremos para trabajar.
En esta parte, es vital que pueda guiarte por la [documentaci√≥n de mongoose](https://mongoosejs.com/docs/guide.html). Notar√°s que tiene much√≠simas similitudes con Sequelize, el ORM que conocimos en el Bootcamp y utilizamos en nuestros proyectos.

### ------------------------------ **Clase** ------------------------------

Vamos a conectar el microservicio con la base de datos creada en MongoDB.

Empezamos creando un servidor de Express super sencillo con la siguiente estructura:

![Carpeta database](./assets/M2/database_folder.png)

`index.js`

```js
const server = require("./src/server");

server.listen(8004, () => {
  console.log("Database service on PORT 8004");
});
```

`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(express.json());
server.use(morgan("dev"));

module.exports = server;
```

`package.json`

```json
{
  "name": "database",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "mongoose": "^7.1.1"
  },
  "devDependencies": {
    "morgan": "^1.10.0",
    "nodemon": "^2.0.22"
  }
}
```

Creo una carpeta `database` dentro de `src`. Dentro de esta carpeta vamos a estar creando la conexi√≥n con la base de datos, vamos a crear nuestros modelos, nuestros esquemas con mongoose para que funcione con la base de datos que tenemos en MongoDB Atlas.

Dentro de `database` creamos un `index.js` y una carpeta `schemas`.

Mongoose va a trabajar los esquemas y los modelos a nivel de aplicaci√≥n.

Vamos a crear el schema para el character.

Es importante que el id quede como un string. Cuando nosotros hablamos de los id en MongoDB, por defecto MongoDB le da a los id un tipo de dato Schema.Types.ObjectId, a cada uno de los documentos que crea, en nuestro caso ya preestablecimos un id, entonces indicamos que es un string.

Creamos `characterSchema.js`:  
`characterSchema.js`

```js
const { Schema } = require("mongoose");

const characterSchema = new Schema({
  _id: String,
  name: String,
  height: String,
  mass: String,
  hair_color: String,
  skin_color: String,
  eye_color: String,
  birth_year: String,
  gender: String,
  homeworld: { type: String, ref: "Planet" }, // REFERENCIA A EL ID DEL PLANETA
  films: [{ type: String, ref: "Film" }], // ARRAY DE REFERENCIAS A PEL√çCULAS
});

module.exports = characterSchema;
```

En el archivo `index.js` de la carpeta `database`, vamos a crear la conexi√≥n con la base de datos.

Antes voy a crear un archivo `.env` donde voy a tener mis variables de entornos y copio la url del cl√∫ster donde esta la base de datos con la que nos queremos concertar:  
`.env`

```js
MONGO_URI = [url] / star_wars;
```

Tambi√©n en la carpeta `src`, creamos una carpeta `config`, dentro de config podemos poner m√≥dulos que tengan que ver con configuraciones de todo tipo. Una de ellas creo un archivo `envs.js`, que es donde nos va a permitir utilizar las variables de entorno, ya que podemos tener muchas variables de entorno, para no estar requiriendo el m√≥dulo `dotenv` en distintos m√≥dulos:  
`envs.js`

```js
// require("dotenv").config();
require("dotenv").config({ path: "../../.env" });

module.exports = {
  MONGO_URI: process.env.MONGO_URI,
};
```

Creamos la conexi√≥n con la base de datos y definimos el modelo de personajes. Podr√≠a hacer una prueba para que me traiga los datas, **en base del modelo que definimos**:  
`database/.index.js`

```js
const mongoose = require("mongoose");
const { MONGO_URI } = require("../config/envs");

const conn = mongoose.createConnection(MONGO_URI);

const Character = conn.model("Character", require("./schemas/characterSchema"));

const Film = conn.model("Film", require("./schemas/filmSchema"));
```

Para relacionar los modelos (colecciones), tengo que popular, nosotros le indicamos, de cualquiera que los campos que nosotros hayamos establecidos que son referencias, podemos popular con ese campo, pero tiene que existir ese esquema, lo creamos:  
`filmSchema.js`

```js
const { Schema } = require("mongoose");

const filmSchema = new Schema({
  _id: String,
  title: String,
  opening_crawl: String,
  director: String,
  producer: String,
  release_date: Date,
  characters: [{ type: String, ref: "Character" }],
  planets: [{ type: String, ref: "Planet" }],
});

module.exports = filmSchema;
```

Modificamos el `index.js` para probar:  
`/database/src/database/index.js`

```js
const mongoose = require("mongoose");
const { MONGO_URI } = require("../config/envs");

const conn = mongoose.createConnection(MONGO_URI);

const Character = conn.model("Character", require("./schemas/characterSchema"));
const Film = conn.model("Film", require("./schemas/filmSchema"));

Character.find()
  .populate("films", ["_id", "title"])
  .then((res) => console.log(res[0]));
```

Quedar√≠a exportar todos los modelos ya creados:  
`/database/index.js`

```js
const mongoose = require("mongoose");
const { MONGO_URI } = require("../config/envs");

const conn = mongoose.createConnection(MONGO_URI);

module.exports = {
  Character: conn.model("Character", require("./schemas/characterSchema")),
  Film: conn.model("Film", require("./schemas/filmSchema")),
  Planet: conn.model("Planet", require("./schemas/planetSchema")),
};
```

Creamos y exportamos todos los modelos.

### ------------------------------ **Fin clase** ------------------------------

## 3

Ya hemos creado nuestros modelos con sus respectivos schemas. Pero, antes de avanzar, veamos algo muy interesante que podemos hacer dentro de nuestros modelos.

Vamos a crearles algunos m√©todos personalizados que puedan ‚Äúenglobar‚Äù distintos m√©todos propios del modelo. Esto en un principio nos ahorrar√° un poquito de c√≥digo a la hora de realizar algunas operaciones, y pareciera que no mucho m√°s‚Ä¶ pero ya veremos m√°s adelante el gran potencial que tiene esta peque√±a t√©cnica.

### ------------------------------ **Clase** ------------------------------

Vamos a hacer una pruebita:  
`/database/index.js`

```js
const server = require("./src/server");

const { Character } = require("./src/database");

Character.find()
  .populate("homeworld", ["_id", "name"])
  .populate("films", ["_id", "title"])
  .then((res) => console.log(res));

server.listen(8004, () => {
  console.log("Database service on PORT 8004");
});
```

Cu√°l es el problema ac√°, nosostros vamos a necesitar m√°s adelante poder unificar un poco los m√©todos que vamos a utilizar. Si queremos hacer un find a alg√∫n modelo, podemos crear un m√©todo que se encargue de eso. Esta funci√≥n no va a poder ser una `arrow function`. Vamos a usar el `this` haciendo referencia al esquema. Si nosotros lo hacemos como una `arrow function` ese `this` se va a estar perdiendo, y necesitamos que el `this` haga referencia √∫nicamente al modelo con el que estamos trabajando:  
`characterSchema`

```js
const { Schema } = require("mongoose");

const characterSchema = new Schema({
  _id: String,
  name: String,
  height: String,
  mass: String,
  hair_color: String,
  skin_color: String,
  eye_color: String,
  birth_year: String,
  gender: String,
  homeworld: { type: String, ref: "Planet" }, // REFERENCIA A EL ID DEL PLANETA
  films: [{ type: String, ref: "Film" }], // ARRAY DE REFERENCIAS A PEL√çCULAS
});

characterSchema.statics.list = async function () {
  return await this.find()
    .populate("homeworld", ["_id", "name"])
    .populate("films", ["_id", "title"]);
};

characterSchema.statics.get = async function (id) {
  return await this.findById(id)
    .populate("homeworld", ["_id", "name"])
    .populate("films", ["_id", "title"]);
};

characterSchema.statics.insert = async function (character) {
  return await this.create(character);
};

module.exports = characterSchema;
```

Prodr√≠a completar lo mismo para los otros modelos.

Luego vamos a empezar a crear las rutas, qu√© van a hacer poquitas, porque con la informaci√≥n que van a venir en las rutas vamos a saber que modelo utilizar. Una vez que sepamos el modelo vamos a llamar al m√©todo. Tenemos m√©todos que se van a llamar iguales para todos los modelos, y nosotros lo √∫nico que tenemos que hacer es cambiar el nombre del modelo. Con eso vamos a tener un c√≥digo m√°s corto y m√°s prolijo.

Tambi√©n podr√≠amos hacer algunas validaciones, dentro de los esquemas usando mongoose o suando middlewares.

### ------------------------------ **Fin clase** ------------------------------

## 4

Ya tenemos creados, no solamente los modelos, sino tambi√©n los m√©todos est√°ticos nuevos que hicimos para cada uno de ellos. Ahora llega la mejor parte. Pongamos nuestro servidor en funcionamiento.

Vamos a crear un enrutado totalmente din√°mico aprovechando los m√©todos que hemos creado a nuestros modelos. Con muy poco c√≥digo, lograremos preparar nuestro servicio para responder con los datos que necesitemos.

### ------------------------------ **Clase** ------------------------------

En la carpeta `src`de `database` vamos a crear una carpeta `routes` con un archivo `index.js`:  
`routes/index.js`

```js
const { Router } = require("express");

const router = Router();

module.exports = router;
```

Completamos el archivo `server.js`:  
`server.js`

```js
const express = require("express");
const morgan = require("morgan");

const server = express();

server.use(express.json());
server.use(morgan("dev"));

server.use(require("./routes"));

module.exports = server;
```

Ahora continuando, sin modularizar, vamos a ver c√≥mo sacarle el jugo a nuestros m√©todos qu√© hicimos en nuestros modelos. En vez de Traer desestructurados nuestros modelos, Vamos a traer el objeto que tiene todos los modelos.

Al haber creado el mismo m√©todo est√°tico para cada modelo, lo √∫nico que tenemos que hacer es indicar el modelo:  
`routes/index.js`

```js
const { Router } = require("express");
const store = require("../database");

const router = Router();

router.get("/:model", async (req, res) => {
  const { model } = req.params;
  const response = await store[model].list();
  res.status(200).json(response);
});

module.exports = router;
```

Ahora creamos una carpeta `middlewares` con un archivo `index.js` y `validateModel.js` para validar nuestros modelos:  
`middelwares/index.js`

```js
module.exports = {
    validateModel: require("./validateModel")
}
```

`validateModel.js`

```js
module.exports = (req, res, next) => {
    const { model } = req.params;
    if (["Character", "Film", "Planet"].includes(model)) {
        return next()
    } else {
        throw Error("Invalid model")
    }
}
```

Completamos el `index.js` de `routes`:  
`routes/index.js`

```js
const { Router } = require('express');
const store = require('../database');
const { validateModel } = require('../middlewares');

const router = Router();

router.get("/:model", validateModel, async (req, res) => {
    const { model } = req.params;
    const response = await store[model].list();
    res.status(200).json(response);
})

router.get("/:model/:id", validateModel, async (req, res) => {
    const { model, id } = req.params;
    const response = await store[model].get(id)
    res.status(200).json(response);
})

router.post("/:model", validateModel, async (req, res) => {
    const { model } = req.params;
    const response = await store[model].insert(req.body)
    res.status(200).json(response);
})

module.exports = router;
```

No tenemos para este microservicio, definido un error personalizado.

Podr√≠amos haber puesto este middleware antes que llegue al enrutador.

Como no hicimos un catch, est√° mandando directamente al manejador de errores de Express y nos responde con toda la traza del error.

### ------------------------------ **Fin clase** ------------------------------

<br>

# HW 2 parte II

